――――――――――――――――问题：
1.第十二章，消息断点。触发的消息断点段在了一段陌生的代码中，然后可以回到主程序的代码，教程说可以通过选中401000这个区段（但是我不清楚在哪里选中这个区段，目前我认为是在【N】窗口中，因为我只在【N】窗口中找到了401000），然后右键set memory breakpoint on access这个选项在窗口中不知道对应哪个断点？我试了“在每个参考点上设置断点和在每个参考点上设置记录断点”，按F9无法运行，教程说可以运行并且可以多次执行？

2.用OD打开以前写的C程序，并且破解

3.十四章中有一条指令：LEA EAX,DWORD PTR DS:[EDX-0x14]
LEA 微机原理中说明的功能是取有效地址，
在这章中的说明是将结果保存到EAX中，这是一回事吗?
（《加密与解密》中这样写道：lea指令允许用户在一个时钟内完成c+a+b+78h计算，其中abc都是寄存器的情况下才有效，会编译成lea c，[a+b+78]指令

例如lea edx，dword ptr [ecx+eax+78]这句代码中，lea指令知识一条纯算术指令，它的实际意义等价于edx=ecx+eax+78，这个78H又是什么意思）

百度：比如你要算EAX*4+EBX+3，结果放入EDX，怎么办？   
  mov   edx,   eax   
  shl   edx,   2   
  add   edx,   ebx   
  add   edx,   3   
  现在用lea一条指令搞定：   
  lea   edx,   [ebx+eax*4+3] // 相当于 lea edx, [eax*4+ebx+3]，这里完全与内存地址无关


在十五章中提到：列入像 LEA EAX,DWORD PTR DS:[401353]这样的指令，并不是移动指定地址内存单元中的内容，而是移动括号中的值，这里是401353.执行LEA指令后,EAX保存了401353这个地址。

4.【ebp-0x10】这条指令好像是清零？？？

5.内存访问断点的作用？什么时候需要设置内存访问断点

6.关于入口点：在十五章中提到：Sambo这个程序的入口点不在401000，因为之前的几个程序的入口点都是401000，现在这个程序的入口点是4D4001，所以判断他的入口点被改了（加了壳），如果没有前面的例子，那该如何判断入口点是否被改了？

7.文件sambo破解过程 有一个问题
8.十五章教程中，正确序列号的解法为：商*0A（CX）+平衡值，但是为教程中说商*0A的值超过了39，就要变换算法=4*0A+平衡值？

9.在破解mexcrk1这个程序的时候，我搜索了字符串，来到提示成功字附近，但是咩有找到比较代码，因为在注释栏中没有给出正确ascll码，不知道为什么，有时候打开能看见，有时候打开看不到。

10.十八章中，在设置条件断点后，我运行起来后，和教程一样输入了9，但是在堆栈数据中却显示的是i（i是第9个字母）这之间有什么关系吗？

11.十七章中对输入的WMY...设置断点 我一开始是在数据窗口中设置的，是不是应该在【D】窗口中设置？ 试一下看能不能成功

12.十八章中，如何判断一个程序是否为Delphi程序

13.二十二章中，在介绍UnhandledexceptionFilter函数的时候，这个函数吧InfoClass设置为7，但是我的OD却设置成了2，不知道为什么（）。并且在执行那条 CALL语句的时候，缓冲区里的数据并没有变成FFFFFFFF，说明该函数检测数没有正在被调试，（可能是我用的论坛上的OD的原因（具体原因为我也不知道？？？）），还有就是发现我的这个程序的代码和教程的代码不一样，不知道也是不是OD的原因

第二十二章大部分讲了手动绕过UnhandledExceptionTricks的反调试，但是基于上面的因素，未能成功调试，所以直接用插件勾选上UnhandledExceptionTricks

但是这样配置好后 我再运行这章中的程序，F9运行后没有反应

14.第二十七章killme破解过程.txt中有一些问题
15.第二十八章crackme破解过程.txt有很多问题
16.第二十九章破解过程.txt问题
17.第三十三章中提到：定位VB的OEP方法：定位VB程序的OEP比较容易,因为VB应用程序都有一个特点-开始都是一个PUSH指令,紧接着一个CALL指令调用一个VB API函数。我们可以使用Patch过的OD,首先定位到VB的动态库,接着给该动态库的代码段设置内存访问断点,

当壳的解密例程解密完原程序各个区段,接着就会断在VB DLL的第一条指令处,接着我们可以在堆栈中定位到返回地址,就可以来到OEP的下一条指令处。这里我们也可以使用前面介绍的方法-跟逐一给各个区段设置内存访问断点(使用Patch过的OD)。
	那么该如何定位VB的动态库，如何给动态库的代码段设置内存访问断点？

18.第三十二章中，方法6说：用专用的OD来加载bitarts_evaluations.c这个程序，运行起来后确实能在日志窗口中看到产生了好几处异常。但是为什么我用52OD运行起来后，却没有显示这些异常。

而且教程判断说这些异常都不是第一区段的，是怎么判断的？
还有这些第一区段，第N区段都是指什么？
19.第三十二章中的方法6，无论是直接对代码段设置内存断点，还是对取消勾选各个异常，shift F9忽略各个异常后对代码段设置内存访问断点，运行起来后都到达了4271B0，教程说这里就是OEP，为什么判断这里就是OEP？还是说如果用“最有一次异常法”忽略最后一次异常后来到的地址都是OEP？
20.第三十二章中：用第7种方法脱壳时，断在GetProcAddress函数后，多次F9能来到OEP，OEP存着是原代码的机器码，只有分析后才能显示正确的汇编代码，可为什么分析后，再删除分析，回不到数据机器代码呢？（这个问题问地我自己都有点不知道该不该问。。。）
21.第三十三章：操作系统中必须知道指向各个API函数名称的字符串的指针，然后通过条用GetProAdress定位到各个函数正确的入口地址并填充到IAT中。那么未修复IAT的程序，已经在IAT中填充了正确的函数入口地址了，为什么不能继续运行。（知道指向API函数名称的字符串的指针就是为了定位获取函数正确的入口地址，那么现在已经知道了正确的函数入口地址，为什么还是不能直接运行）是不是因为：如果操作系统不同的话，这些入口地址都会改变？所以才要先用指针指向函数名称，然后再获取地址？那又回到刚刚那个问题，现在IAT中已经填充了正确的函数入口地址，为什么还是不能直接运行？
22.第三十四章中：用OD打开重建后的文件，OD会提示入口点位于代码段之外因为UPX壳将代码段指定到了第三个区段。现在要修复这个问题（如果用52OD不会弹出这个提示窗口，原因不详，可能是哪个插件，但是原版OD还是会提示。我在看雪这章教程中提了问，为什么52OD自动修复了这个问题?2017.11.12  	答：	）
23.52OD的问题：第三十六章中，说执行pushad后设置硬件断点，F9运行，但是运行起来后没有断下来，不知道为什么，原版OD就可以


24.第三十七章：在用IMPROT REC插件修复IAT的时候，教程说可以按照前面介绍的3种方法进行手工修复剩下的4个项IAT，但是现在又有很多问题：1.如果要按照前面的第1种或者第三种方法，就得知道在哪里调用了RVA，比如说 CALL [...]这样的语句，那我在数据窗口中在IAT项上find reference，但是这个表里是空的也就是无法定位到在哪使用了这个RVA，那么也就无法使用第一种方法种的“在关键语句和他下一条语句设置断点，给RVA设置内存访问断点，运行到第一个断点后 trace into”和第三种方法“设置[esp]==关键语句&&byte[eip]==0c3”，因为这两种方法都需要知道这条语句在哪，但现在find reference表为空，所以要怎么手工修复IAT？
	自己猜测：就是到达OEP后，往下找例如call 【46......】这样的语句，然后用方法1或者方法3进行修复，那还是之前那个问题，无效的指针，在find reference里都没有找到，那可能在原程序中都可能没有。

25.第三十七章中：用跳转法修复IAT后，有两种情况，如果遇到第一种情况，壳有自校验，怎么办？
26.第三十七章：在这章中验证了如果删除无效指针项，也可以成功运行，是不是碰到无效指针项都应该删除？

第三十八章：
27.这里在用ESP定律的时候和之前说的ESP定律有点不同：在设置硬件断点后，运行起来，来到跳转处，这个程序如果不给401000设置内存断点，单步步入步过后虽然能来到OEP处，但是F9运行起来后直接终止了（不知道为什么）

第三十九章
28.如何判断OEP是伪OEP，或者说如何判断代码被壳偷了
29.笔记中：设置command is one of后如何判断哪些是真正的stolen bytes没搞明白，因为在操作过程中和教程有很大差别，做到commands is one of后就跳过了。
30.教程中说OD不能跟进ring0，在KiUserExceptionDispatcher函数入口后面有个CALL函数，教程说不能跟进ring0，是说不能跟进这个call吗？但是我可以enter进这个call，所以我不知道教程说的不能跟进ring0是什么意思

31.在笔记中有这样的描述："RET 10H来说,除了完成RET的操作之外,ESP还要增加10h"，那ret 后面的操作数是任意大小的吗？





























