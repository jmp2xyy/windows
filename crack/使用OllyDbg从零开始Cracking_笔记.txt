1.通常 OllyDbg 显示程序的某些部分时是不正确的，错误的将可执行代码解释为数据。这种情况，你可以在反汇编窗口中右击选择 【Analysis -> Remove analysis from module】 手动删 除分析结果
2.快捷键：
	【F7】 执行一行代码，遇到 CALL 等子程序时会进入其中，进入后首先会停留在子程序的第一条指令上。
	【F8】 执行一行代码，遇到 CALL 等子程序不进入其代码。
	【F2】 在显著行设置断点，再次按 F2 删除断点
	【F9】 运行调试程序，直到遇到断点停止运行
3.？ AX（问号也可用于查询寄存器的值）

4.反汇编窗口：空格键更改汇编指令，F7步入
5.【ctrl+gray】=New orgin here=此处为新EIP
6.内存中的内容是倒序存放的
7.【汇编语法知识】JA,JB,JBE,JAE的两个操作数都是正数(无符号数)，而JG,JL,JLE,JGE把两个操作数都看成有符号数。
8.针对于call指令,OD提供了一些有用的跟踪机制。如果想继续跟进子程序内部,你可以按F7键跟进。如果只是想先看看子程序里面的内容再决定要不要跟进的话，可以单击鼠标右键-“Follow”。最后，如果我们不想继续跟踪该子程序了,我们可以按下F8键,继续执行call指令的下一条语句。
OD允许我们看我们感兴趣的子程序里面的内容,但是不执行,只需要在call指令上面单击鼠标右键选择“Follow”。如果我们想回到之前的那一行的话,我们可以按数字键减号。这个键可以让我们回到按“Follow”的那一行。
9.一般情况下,在改变程序代码后不要忘了重新分析代码。有的时候,代码分析可能是错的,这个时候应该选择“Analysis”-“Remove analysis from module”。
10.你可以在数据窗口中,单击鼠标右键选择-Go to-Expression,然后输入地址40366C。还有一个更加简单的方法:在第一条指令上面单击鼠标右键选择-Follow in Dump-Immediate constant
11.【指令】【LODS】：从源地址拷贝数据到EAX中
12.【指令】【STOS】 ：该指令是将EAX的值拷贝到EDI指向的内存单元中。
13.要想在指令执行之前看到真实地址,需要在该指令上下断点,断下来以后查看寄存器的值或者查看解释窗口中的提示信息。
14.通常情况下,状态栏会显示调试器暂停的原因。
15.【LoadIconA】是在User32.dll中实现的一个加载位图的应用程序接口
16.在API名称列表中，按API函数名称的首字母键就可以找到该函数的位置，然后右键Follow import in Disassembler（反汇编窗口中跟随函数）
17.BP是在指定的函数的第一条指令处设置断点。而不是在函数的调用处。
18.根据stdcall的调用约定,API的参数通常从右至左的在堆栈中排列。
19.RET 10H来说,除了完成RET的操作之外,ESP还要增加10h。
20.【B】：breakpoints（断点窗口）
21.（>),这表示,该处是一个跳转地址。我们顺着红线可以找到跳转来至于哪里
22.如果需要保存修改到可执行文件的话,请执行以下操作：右键，复制到可执行文件，所有修改，选择全部复制，弹出一个新窗口,再次单击鼠标右键选择-Save File。
23.Breakpoints, 条目 0
 地址=00401018
 模块=CRACKME
 激活=始终
 反汇编=or eax,eax
24.当我们设置断点后,OD会将对应指令处第一个字节指令替换成CC。但是为了不影响界面显示效果,OD会将CC显示为原字节
25.除了F2设置断点以外,我们还可以通过命令栏来设置断点,如下：BP 401018
26.BPX可以给引用或者调用了指定API函数的指令都下断点
27.双击机器码也可以设置断点，删除同理
28.内存访问断点有两个缺点:1.它们不会出现[B]断点列表中和其他的地址。所以,你必须记得设置在什么地址处。2.不能同时设置多个内存断点。如果你设置了一个那么你之前设置的就会被自动删除。
29.【M】按钮：打开内存窗口 这个列表包含了CrackMe加载的一些区段以及其加载的一些DLL的区段,
30.如果你想要返回到主程序模块中,可以选择主菜单项-Debug-Execute till user code。（alt+F9）   有的时候,这个方法不起作用。我们可以在函数返回指令处（retn处）设置断点,然后运行起来,等中断下来以后,再F7或者F8单步到主程序的代码中。
31.在同一个API函数中,如果通过bp命令设置断点会被程序检测而导致断点失效的话,也许设置内存访问断点可以绕过这个检测。设置内存访问断点这个方法也可以通过检测内存页的属性并恢复内存页的属性来进行保护,但是这在反调试技巧中并不常见。
32.OD中最多设置4个硬件断点，如果要设置第5个，需要删除其中一个
33.OD查看硬件断点窗口：选择调试――硬件断点
34.硬件访问/写入断点是断在触发硬件断点的下一条指令处和内存断点不同
34.【L】按钮打开日志窗口。
35.消息循环有特定的API函数构成，最常见的是GetMessage 和DispatchMessage函数，有的消息循环也会用到其他的API函数
36.【W】按钮打开Windows窗口
如果【W】按钮弹出的窗口列表为空,你可以单击鼠标右键选择-Actualize（刷新）。
37.获取编辑框中文本我们通常使用的API是GetDlgItemTextA（用于获取用户输入的序列号）或者GetWindowTextA。当然,也可以使用Unicode版的API函数GetDlgItemTextW或者GetWindowTextW,再者,也可以发送消息直接获取编辑框中文本（有时候GetDlgItemTextA并不意味着这个函数就是用来读取用户输入的用户名和序列号，可能仅仅是获取用户输入的其他字段的，有可能作者是故意添加该函数来误导）
38.如果应用程序不是通过API函数来获取用户输入的序列号的话，我们可以通过消息断点来定位
39.如果只想在OD中记录下程序接受到消息,但是不希望程序中断下来：可以使用另一种形式的消息断点。我们选择工具栏中的【B】按钮打开断点窗口,删除所有断点。然后设置一个针对于值为0x202的WM_LBUTTONUP的消息断点
40.消息断点如果没触发，说明当前程序没有通过API函数来获取用户输入的用户名和序列号
41.为了记录下程序接收到的(按钮,输入的文本内容)等所有信息,我们可以对消息处理函数TranslateMessage或者DefWindowProcA设置条件断点。如果想完整的记录下这两个API函数的参数信息,我们可以
通过命令栏BP给TranslateMessage和DefWindowProcA设置断点。然后 【B】――依次进入两个断点设置条件断点，表达式里写MSG,例如:WM_LBUTTONUP的值为0x202,那么MSG就等于0x202。（记录结果最好保存到文件中，现在日志中记录了窗口过程函数接受到的所有消息，有个这个日志文件,我们就可以在其中挑选我们感兴趣的消息。然后设置相应的消息断点来印证我们的猜想。）

十三章：
42.概念：硬编码序列号就是不依赖于用户名来生成，总是由固定的字符和数字构成的固定不变的字符串。（最简单的硬编码序列号，正确的序列号是作为全局字符串出现在程序中的。）
43.想要找到所有的全局字符串，在反汇编窗口中右键-查找所有参考文本字串
44.【R】文本字串参考
45.有些程序故意放置一些假的序列号在字符串列表中
46.在设置断点后，程序停下后，有的API函数没有执行，但是想继续执行，可以选择 调试――执行到函数返回（再按F7（单步返回）可以回到主程序中）。
47.第十三章：教程说可以在Leccion 13 HARDCODED 1中输入FIACA可以看到正确结果，教程过程中，代码分析时，程序比较用户输入的前4个字节和FIACA做比较，所以输入FIAC时也能得到正确的结果。

十四章：
48.【GetWindowTextA】:获取用户输入的序列号
   【lstrcmpA】:用于字符串比较
   【MessageBoxA】：用于显示一条消息,提示是正确或者错误的序列号。
49.【方法】：在给函数【GetDlgItemTextA】（或者是其他函数）设置断点后，可以注意下堆栈中的BUFFER中的参数（或者是其他函数的参数），右键――在数据窗口中跟随，然后按调试――执行到返回（这里也不一定是执行到返回，也可能用F8单步步过）――F7返回到主程序代码中，然后进行可能的调试，如F7等等
50.【MOVSX】：带符号扩展，并传送。MOVSX指令将指定字节保存到
【（一个寄存器）】中,如果该字节是正数,高位补零,如果该字节为负数高位补1


十五章：
51.【方法】：F9――在（入口401000  .text区段上设置内存断点）――分析代码（完美分析后的代码。现在我们位于代码段,我们查看当前模块使用了哪些API函数-但是我们在程序刚刚加载的时候不能这么做,因为那个时候我们查看当前模块使用的API的话是查看的壳所在模块使用的API函数,现在就不一样了。）――查看字符串列表――双击关键字（这里是You did it！）来到此代码段附近，找到一些比较指令和跳转指令，在该条件跳转指令上面设置一个断点来验证是不是一个关键的跳转，并且通过鼠标右键选择【记得这步要删除之前设置的内存断点！！！！】，运行程序――接着试着修改标志位看看会不会弹出提示序列正确的消息框（这里双击了Z标志位），这里弹出了正确的消息框，那么这个跳转就是决定序列号正确与否的关键跳转。可以在跳转的上面一个条件出设置一个断点，运行，然后――【方法】：在输入错误的序列号后，如果堆栈中能看到输入的参数，则在数据窗口中跟随，然后拖选中错误的序列号，右键――断点――内存访问。如果这个条件中将我们输入的错误序列号与正确的序列号进行比较的话,就会断下来。（这点很重要），此时,如果我们运行起来,如果这个CALL中访问我们错误序列号的话,OD将中断下来――F9，这里没有中断下来，说明比较还在前面,所以我们可以考虑反复通过上面的方式在还要靠前的地方设置断点,或者我们可以以程序获取用户输入的序列号作为入手点,但是这里并没有使用GetWindowTextA函数,但是我们知道有将虚拟键消息转换为字符消息的函数。【记得删除内存访问断点】

52.在【M】中可以用【ctrl+L】来看看有没有其他内存区域有该错误序列号（就是查找下一个）

53.当WM_LBUTTONUP消息到达的时候,断了下来时，――执行到返回――F7回到主程序模块中，现在我们有两种选择,第一种-我们对.text节设置内存访问断点,然后F9键运行起来看看哪里在进行序列号的比较,这对于我们来说是比较困难的,我们可以看到,代码量有点大。第二种选择-就是在内存搜索一下我们输入的序列号，具体实现【方法】：【M】――查找――在ASCLL中输入已输入的错误的序列号，（这里还可以参考面一条笔记.52），然后在数据窗口中对错误的序列号设置内存断点，当程序拿错误序列号进行比较的时候就会断下来。――F9运行

54.*.SFX是一种文件扩展名，通常为二进制文件
55.【方法】查找命令：可以查找到指定的代码

十六章：
56.【方法】比如一个程序需要输入用户名和序列号，这时候给GetDlgItemTextA函数设置断点，运行后2次执行到返回，2次查看堆栈中BUFFER的数据，并且在数据窗口中跟随，从程序的角度出发，程序就会取用户输入的错误序列号与根据名称生成的正确序列号进行比较，所以我们可以对错误的序列号设置内存访问断点，看看程序的哪些地方使用了。在数据窗口中拖选错误的序列号，――断点――内存访问――运行――

57.在跟踪一个循环时会很繁琐，那么就可以忽略这个过程：在循环的下一条指令处设置一个断点,然后按F9键,就会中断下来，然后查看这条指令中的寄存器的值：双击

58.【指令】CDQ:双字扩展,把EDX的每一位置成EAX的最高位，再把EDX扩展为EAX的高位，也就是说变为64位
《加密与解密》中过这样解释：其作用是把eax寄存器中的数视为有符号的数，将其符号位（即EAX的最高位）扩展到EDX寄存器，即若eax的最高位是1，则执行后edx的每个位都是1，结果edx=FFFFFFFF，若eax的最高位是0，则执行后edx的每个位都是0，结果edx=0000000.这样就把eax中的32位带符号的数变成了edx：eax中的64位带符号的数，以满足64位运算指令的需要，单转换后的值没有变化。

CDQ指令双字扩展,把EAX中的符号位扩展到EDX中去,然后EDX:EAX对应的值除以ESI,商保存到EAX中,余数保存到EDX中。EAX符号位扩展到EDX中,EDX的值应该变为零,相当于对EDX进行XOR EDX,EDX操作。现在不需要将EDX清零了,因为CDQ指令已经帮我们完成了该操作。

50.【MOVSX】：带符号扩展，并传送。MOVSX指令将指定字节保存到
【（一个寄存器）】中,如果该字节是正数,高位补零,如果该字节为负数高位补1
例如：
1.MOV BL,80H
MOVSX AX,BL
运行完以上汇编语句之后，AX的值为FF80H。由于BL为80H=1000 0000，最高位也即符号位为1，在进行带符号扩展时，其扩展的高8位均为1，故赋值AX为1111 1111 1000 0000，即AX=FF80H。
2.mov CL, 50H
MOVSX AX, CL
50H=0101 0000，最高位为0，则AX为0000 0000 0101 0000
结果AX = 50H
如果在破解的过程看到这样的指令：MOV 寄存器，DWORD PTR 一个寄存器，就表示读取两个字节的值

十七章：
59.【方法】：（情况）在破解mexcrk1这个程序的时候，我搜索了字符串，来到提示成功字附近，但是咩有找到比较代码，因为在注释栏中没有给出正确ascll码，不知道为什么，有时候打开能看见，有时候打开看不到。解决办法：右键――中文搜索引擎――搜索ascll，就可以看到关键跳转字在哪条比较语句上了。


60.十七章教程可以破解那种没有错误或者正确提示的程序（不一定要给提示窗口下断点，这种程序在输入序列号时，就会保存到内存中，就可以在【M】窗口中查找）



十八章：
61.【方法】这章中的程序没有注册按钮，可以先给TranslateMessage函数设置条件记录断点，如果你不知道要拦截什么消息的话，那就先单击工具栏中W按钮打开窗口列表找到CrackMe的主窗口这行,在上面单击鼠标右键，打开Messages消息下拉框，找到WM_KEYUP消息（101），所以我们关闭该窗口,打开TranslateMessage断点所对应的条件记录断点窗口来设置条件MSG==101

62.如果一个程序是Delphi的程序（Delphi程序是经过深度封装的程序,）可能在与正确的序列号进行比较之前内存单元中序列号已经经过了很多次的内存的中拷贝了,所以直接对该字节设置内存访问断点是不可取的，所以先在内存中搜索我们输入的序列号,定位到以后再对区域设置内存访问断点可能更方便一些。

63.通过内存列表【M】查找输入错误的序列号时，正确的步骤是：查找――来到【D】窗口，ctrl+l，没有，就说明这个区段没有别的关键字了――然后还要回到【M】窗口，ctrl+l来查找下一个区段――重复以上步骤（错误的序列号可能在多个区段中，但是如果仔细查找，上下翻，也许能看到一些其他的序列号（与错误序列号来进行比较的正确序列号）这就是我们要找的正确区段）

第十九章：
64.【IsDebuggerPersent】:表示在被调试器调试情况下，调用该函数会返回正在被调试，并且该函数是被Kernel32.dll导出的，该函数没有参数，如果当前程序正在被调试的话，返回值为1，没有被调试的话，返回值为0.
65.跟其他API函数一样，IsDebuggerPersent的返回值也保存在EAX中
所以可以通过BP IsDebuggerPresent，然后运行――执行到返回，看EAX的值，这个就是IsDebuggerPersent的标志位（参考第64条）



66.在调试这章中的crackme1时，因为用的不是原版OD，用的是吾爱破解专用OD，这个OD中已经含有绕过IsDebuggerPersent检测的插件。
67.【PostQuitMessage】：该API函数给线程消息队列发送一个WM_QUIT消息来关闭窗口
68.这三条不伦不类的MOV指令：
			    MOV EAX,DWORD PTR FS:[18](FS是啥？)
（FS是指向了一个结构体,该结构体包含了有关正在运行的程序的一些非常重要的信息）
(该结构被称为TEB或者TIB(线程环境块),该结构保存了有关当前程序的非常重要的信息。例如,TIB被存储在哪里,程序堆栈从哪里开始以及到哪里结束。

)


			    MOV EAX,DWORD PTR DS:[EAX+30]
			    MOVZX EAX,BYTE PTR DS:[EAX+2]
就将EAX的值置为1（如果正在被调试则置为1，如果没有被调试则置为0）
69.绕过反调试函数插件的原理：
	当前程序开始运行的时候,在内存的某处存放在一个特殊的标志,通过该标志来检测当前程序是否正在被调试,如果该标志为1-当前程序正在被调试,如果该标志为0-当前程序没有被调试。这个特殊的字节的值	可以通过IsDebuggerPresent或者上面3条指令读取出来。
70.如果堆栈中显示【SEH】，说明该地址与异常相关
（SEH：即结构化异常处理，是windows操作系统提供给程序设计者的强有力的处理程序错误或异常的武器）


第二十章：
71.【调试器】：选项――调试设置――安全勾选上面3个复选框，再给API设置断点，重启OD后设置的断点依然存在
72.有时候重要的API函数会隐藏起来
73.如果程序不直接导入某些API的话,会使用GetProcAddress这个API 函数来获取这些API函数的地址进行间接调用。使用GetProcAddress函数加载的一些API函数并不会出现该API函数列表中
74.给GetProAddress函数下了断点后，可以一直F9直到在堆栈中找到想要的函数

75.【Enumprocesses】：返回正在运行的每个进程的标识即PID
76.【PID】：PID是系统分配给每个正在运行的进程的标识符-每次启动的时候都会发生变化
   打开任务管理器――服务就可以看到每个进程的PID值（这个值是十进制）
77.【PID跟句柄有什么区别呢?】很简单。PID是用于区别不同进程的标示符,一个进程被创建后这个进程的PID就是不变的,除非进程重新启动。当前,OD的进程PID是2D4。而句柄实际上是一个指针,它指向一个包含具体数据结构的内存,可能当做索引,所以句柄是你每次访问该进程的时候获取的,使用完毕后要释放,然后通过该句柄可以对该进程进行相应操作。
78.【OpenProcess】：如果调用成功，返回值为指定进程的句柄
79.【H】：可以查看OD的句柄列表
80.如果另一个进程调用EnumProcesses获取OD的进程PID的话,仍然会是2D4,但是获取进程句柄的话,会是另外一个值,因为句柄在系统中是独一无二的。
81.当我们请求获取进程中模块句柄的时候,系统会返回该模块在进程内存中基地址(模块起始地址)

82.【方法】：以上的这种方法并不一定能绕过这个反调试,其实我们可以通过将OLLYDBG.EXE创建一个副本,将其重命名为PIRULO.EXE,然后运行该程序,被其调试的程序将无法找到一个进程名为OLLYDBG的进程了。
有一点很重要就是在OD的文件夹下面留一个原始的OD,避免OD的插件出现问题。

第二十一章：
这章中药用到的程序我无法打开，用OD打开运行直接终止，直接打开程序也终止
83.像这张中的CrackMe，整个程序就只有一个ExitProcess,其他API都是通过GetProcAddress加载的，并且GetProcAddress也不在函数列表中（所以这是可以直接在命令栏中输入bp  GetProcAddress）
84.论坛里有这样的对话：
某楼主：那个buggers3的程序逻辑是不是有点问题啊，怎么跟自身进程名相比较相同的话就直接中断循环提示没被调试呢，他怎么知道buggers3.exe一定会出现在Ollydbg.exe之后呢！我看msdn的Process32Next等函数里也没有说明列举出的进程名的排序的依据啊！
安同学：你阅读很细心,这个例子是不够严谨,并不能确保进程名的先后顺序... 只是为了介绍这一章的知识点而已...

85.在用GetProcAddress加载一些API的时候，如果我们对哪些API感兴趣，就可以执行到返回，就知道该函数的地址了，然后使用BP EAX断这个函数，因为EAX中保存了GetProcAddress获取到的函数地址

86.Process32First配合Process32Next这个API函数可以读取进程快照中所有正在运行的进程的相关信息
87.使用WinDowse时，用原版OD可以和教程有相同的效果，用吾爱破解OD不行


第二十二章：
88. 章大部分讲了手动绕过UnhandledExceptionTricks的反调试，但是基于上面的因素，未能成功调试，所以直接用插件勾选上

89.在吾爱破解OD上的插件增加：增加了HideOD.dll
可以看到很多HideDebugger插件中没有的选项,我们和HideDebugger配合起来用,有一点很重要,就是别忘了勾选上Auto Run HideOD这个选项,这样我们就不必每次启动OllyDbg的时候配置该插件了。

但是这样配置好后 我再运行这章中的程序，F9运行后没有反应


90.【Unhandled exception】和【SetUnhandledExceptionFilter】函数会检测调试器


SetUnhandledExceptionFilter：该函数的唯一一个参数为异常处理函数指针。当程序发生异常是,且程序不处于调试模式(在VS或者其他调试器里运行)则首先调用该异常处理函数。因此,程序可以主动抛出一个异常来判断当前程序是否正在被调试

Unhandled exception（系统默认的异常处理函数）：（MSDN）:一个应用程序定义的函数，将未处理的异常传递给调试器，如果进程被调试。否则，它可选地显示一个应用程序错误消息框，并导致异常处理程序被执行。只能从异常处理程序的过滤器表达式中调用此函数。


91.这章中原博主给的注释：
		本章内容可以结合simonzh2000兄帖中Jeremy Gordon, Hume总结的异常处理顺序来理解
			发生异常时系统的处理顺序(by Jeremy Gordon, Hume): 

    1.系统首先判断异常是否应发送给目标程序的异常处理例程,如果决定应该发送,并且目标程序正在被调试,则系统 
    挂起程序并向调试器发送EXCEPTION_DEBUG_EVENT消息.

    2.如果你的程序没有被调试或者调试器未能处理异常,系统就会继续查找你是否安装了线程相关的异常处理例程,如果 
    你安装了线程相关的异常处理例程,系统就把异常发送给你的程序seh处理例程,交由其处理. 

    3.每个线程相关的异常处理例程可以处理或者不处理这个异常,如果他不处理并且安装了多个线程相关的异常处理例程, 
        可交由链起来的其他例程处理. 

    4.如果这些例程均选择不处理异常,如果程序处于被调试状态,操作系统仍会再次挂起程序通知debugger. 

    5.如果程序未处于被调试状态或者debugger没有能够处理,并且你调用SetUnhandledExceptionFilter安装了最后异 
    常处理例程的话,系统转向对它的调用. 

    6.如果你没有安装最后异常处理例程或者他没有处理这个异常,系统会调用默认的系统处理程序,通常显示一个对话框, 
    你可以选择关闭或者最后将其附加到调试器上的调试按钮.如果没有调试器能被附加于其上或者调试器也处理不了,系统 
    就调用ExitProcess终结程序. 

    7.不过在终结之前,系统仍然对发生异常的线程异常处理句柄来一次展开,这是线程异常处理例程最后清理的机会.

――――――――――以下是《加密解密》中，调试器篇中的笔记――――――――――
92.【S】：源码调试
如果一个程序，比如我用VS 写的一个程序，就可以先用OD打开.EXE文件，然后【查看――源码、源文件】中就会出来一个.CPP文件，双击它就可以看到源码，可以在源码上做调试

93.硬件断点和DRx调试寄存器有关
  DR0~DR3：调试地址寄存器，保存需要监视的地址，如设置硬件断点
  DR4~DR5：保留，未公开具体作用
  DR6：调试寄存器组状态寄存器
  DR7：调试寄存器组控制寄存器
  硬件断点原理是使用4个调试寄存器（DR0，DR1，DR2，DR3）来设定地址，以及DR7设定状态，因此最多只能设置4个断点。

94.内存断点：原理是对所设的地址设为不可访问/不可写属性，这样当访问/写入的时候就会产生异常（OD截获异常后比较异常地址是不是断点地址，如果是就中断，让用户继续进行操作）

95.执行复制到可执行文件时，出错“Unable to locate data in executable file”
解决方法：这个要修改的地方不在RawSize范围内，修改PE文件，使"RawSize=VirtualSize"

96.能否把CALL调用改成函数名形式
解决方法:比如CALL 401496 假设401496处是amsg_exit函数，将光标停在401496，按 "Shift" + "；" 键,出来一个标签框，输入字符“amsg_exit”这样，所有调用401496的CALL都变成CALL<401496>形式


――――――――――――――――――――――――

第二十三章：
//97.找到IsDebuggerPresent标志位的方法：直接在命令栏中输入 BP IsDebuggerPresent（注意：这里直接通过API列表查找可能没有，之前的章节也介绍过，因为有的API函数会被隐藏起来），运行――执行到返回
其实最简单的做法就是EIP在入口点处时找到EBX寄存器的值,然后单击鼠标右键选择-Follow in Dump

98.插件中的HideNtDebugBit选项，勾选上就会绕过ProcessHeap和NTGlobalFlag的检测
ProcessHeap和NTGlobalFlag是两个标志位，定位方法：首先找到IsDebuggerPresent标志位，最简单的做法就是EIP在入口点处时找到EBX寄存器的值,然后单击鼠标右键选择-Follow in Dump
NTGlobalFlag位：EBX的值加上0x68（如果不为0，则表示正在被调试）
ProcessHeap位：EBX的值加上0x18，对数据窗口中的4个字节的数据在数据窗口DWORD跟随，偏移0x10的位置的4个字节就是HeapFlags标志了


99.这里要提到一点就是：OD存在一个BUG，当被调试程序通过OutputDebugString输出超长的一串调试字符串的时候，OD无法处理导致崩溃，可以通过插件中的OutputDebugStringA选项来修复OD的这个BUG，这里引用Juan Jose的execryptor脱壳教程中一段话来解释:可以通过OutputDebugStringA输出一长串%s字符串，OD无法处理这么长一串字符串，就会发生错误。我们可以使用HideDebugger插件来修复这个bug。这里我给OutputDebugStringA传递的参数长度为100的%s字符串。

第二十四章：
这章也是先介绍用插件绕过反调试，和手工绕过反调试
100.【指令】：POPAD：从堆栈中恢复各个寄存器的值
101.当看到OD中代码有问题时，在分析里删除分析的代码，因为OD有可能会将代码当成数据带分析。
102.【方法】：为了让程序发生异常可以停下来,我们去掉忽略所有异常的选项,第一个选项还是保持勾选。
103.INT 68是少数OD无法处理的异常之一，直接用NOP指令填充即可（可能需要将所有的INT 68指令都替换掉，查找――命令）
104.GetProcAddress可以通过GetProcAddress函数来加载其他API函数，通常给这个函数加一个断点
105.CreateToolhelp32Snapshot：该函数给当前运行的所有进程创建快照



第二十五章：
___________内存访问异常_____________：
106.VirutalProtect:（百度百科）：是对应 Win32 函数的逻辑包装函数，它会在呼叫处理程序的虚拟位置空间里，变更认可页面区域上的保护。
程序会根据PE头中的相关信息设置区段的初始权限,当然也可以使用诸如VirutalProtect这类API函数在运行时修改权限。


107.【方法】：在OllyDbg中我们【如何查看各个区段的初始权限呢,还有就是如何修改这些权限呢】?
按【M】：可以看到主模块的所在的区段地址（这里是400000），在数据窗口中定位到PE头（PE头中保存了各个区段的名称,长度以及程序运行所必须的一些信息）（转到400000）
  其实OllyDbg中有一个可以解析PE头的各个字段的选项,我们可以在数据窗口中单击鼠标右键――指定――PE文件头，就可以看到显示出了DOS头的各个字段信息，继续往下看，
1.首先会看到Offset to PE signature  这是告诉我们PE头的偏移量,我们可以看到偏移量为100，数据窗口中转到400100，这里是关于程序的重要信息。比如AddressOfEnterPoint=1000，也就是说基地址400000加上1000就是程序的入口点。（如果你想修改入口点的话,例如把入口点修改为2000,我们可以在入口点这一行上单击鼠标右键――修改整数这里我们可以输入任意数值,例如:如果你想让程序从402000处开始执行,我们可以输入2000。这个2000是相对于映像基址400000的偏移量。修改完毕以后,我们可以单击鼠标右键选择-Copy to executable file,然后在弹出的窗口中单击鼠标右键选择-Save file,这样就可以保存到文件了。）
2.接下去看到，虚拟地址VirtualAdress。注意这里是偏移量,实际上内存地址为401000,并且Characteristics(特征)为CODE,EXECUTE,READ(代码段,可执行,可读)。如果我们【想让该区段具有可写权限】的话,我们可以将Characteristics这个字段的60000020修改为【E0000020】,这样该区段就具有了【所有权限】。【注意】在保存修改的文件时，鼠标应该停在数据窗口，而不是代码窗口（这2者会不一样！），然后运行保存的新程序时，修改的代码会没有，但是权限已经修改了，所以需要重新输入第一条代码（这里是mov dword ptr ds:[401057],eax），再运行，即可发现内存访问异常已被解决。
108.【注意】上一个例子已经说明了：保存文件时，鼠标在数据窗口右键和在代码段窗口右键是不一样的


__________除以0异常________________

_________无效指令,尝试执行特权指令异常________
109.什么是SEH呢:（Structured Exception Handling ）来确保该程序可以从错误中恢复,也就是说,如果你没有设置SEH,那么当程序中有异常发生时,程序就会弹出一个错误信息框,告诉我们程序即将关闭。如果我们设置了SEH的话,异常处理程序就能够捕获到程序中发生的异常,进行相应的处理后,就会把控制权重新交予程序继续执行,程序并不会终止也不会弹出那个烦人的错误消息框。
110.每个线程都可以有自己的异常处理程序,如果当前异常处理程序不予处理的话,可以将异常将于SEH链中的其他异常处理程序来处理


111.【方法】：【如何定位异常处理程序】：
打开一个程序，如果在堆栈中看到End of SEH chain(SEH链尾部)和SE hander（SE处理程序），表示这是系统默认安装的异常处理程序,无论什么异常交予该默认异常处理程序处理的话,它都会弹出错误消息框


112.打开程序后，在数据窗口中定位到FS:[0]所指向的内存单元，里面存了一个堆栈地址，这个地址指向的是SEH链的最后一个节点，当前异常被交予该结点的异常处理程序的话,就会弹出一个我们熟悉的错误消息框
【如何查看SEH链的情况】：查看――SEH链，这里就能看到程序有没有自己的异常处理程序，像cruehead’a 的CrackMe没有，但是像smartmouse111这个例子就有，OD也标识出“SE处理程序安装"

第二十六章：
113.破解VB程序有更好的工具，比如说Smartcheck
114.【关于OD】：当我们需要破解VB程序,或者需要定位OEP,再或者需要内存访问断点仅对内存执行断点生效的时候我们就可以使用Patch过的OD（在OD目录下）。

但是如果我们需要读取或者执行都能生效的话,我们就可以使用硬件访问断点来替代。
115.VB API函数资料 见OD\\专用OD\\word文档
116.NAG窗口：软件未注册或软件的试用版经常会弹出一些提示窗口要求注册,这些窗口被称为NAG窗口
117.如何去除NAG窗口：见第二十六章破解过程.txt
第二十七章：
118.VB程序有个特点――入口点出都是以个PUSH指令，然后一个call指令，如果你遇到的不是这种情况的话，那么该程序可能被加过壳。
119.4C法并不适用与所有的程序，只能用常规手法（具体见“第二十七章破解过程.txt”）
第二十八章：
120.在寻找正确的序列号时，可以从两个方向入手：第一：直接对比较函数设置断点，如果发现有疑点（比如说会断下来很多次），那么就用第二种：对错误提示框设置断点（即对消息框函数设置断点）
121.很多人说我们不能修改系统库文件,会导致其他程序不能用的,实际上我们可以将VB的库文件拷贝至跟待破解的目标文件同一个目录即可,那么修改了的VB库文件只会的当前文件夹的目标文件起作用,操作系统里的其他应用程序还是会继续使用system32目录下的VB 库文件,两者不会冲突。
122.目标文件如果需要加载特定的库文件的话,首先会搜索当前目录下有没有,如果当前目录下面有就直接加载,如果当期目录下面没有,就会继续前往system32目录下搜索
123.用OD还可以修改动态链接库的权限。

第二十九章：（这样的教程主要是介绍操作码，笔记主要记录一篇微博中的方法、经验）
【我在这章中发现一个OD软件的问题】：因为加载的这章中的程序会直接终止，所以我用原英文版的OD加载，发现能正确加载（入口点什么的都是正确的），那我就想把52OD的载入配置复制过来，发现加载了ollydbg.ini和ollydbg_白底黑字.ini就发生用52OD加载的错误（综上，这个程序可以用原英文版OD加载）
124.VB编写的应用程序有两种编译方式：Native编译的代码和P-code的主要区别在于：
Native是直接执行代码段中的代码的。

（破解VB程序先理解这个概念）P-code,实际上是一组自定义的指令集,必须通过基于堆栈的虚拟机翻译为80X86上的指令集才能执行,即通过msvbvm50.dll和msvbvm60.dll这两个动态库来解释执行。也可以理解为通过P-CODE告诉虚拟机将要进行什么操作例如:1e  表示  执行无条件跳转(JMP)1e意味着执行无条件跳转,该无条件跳转是通过虚拟机(msvbvm50.dll,msvbvm60.dll)来执行的,也就是说P-CODE程序会读取代码段中的值,然后由这些值来告诉虚拟机需要执行什么操作。这也就是为什么我们说P-CODE程序的代码段中没有可执行代码的缘故。

而对于P-code，如果我们使用之前那个Patch过的OD加载它,并且给代码段设置内存访问断点的话(实际上是内存执行断点),除非是直接调用API函数,否则不会断下来。


原博地址：***http://blog.sina.com.cn/s/blog_4a0824490100wcmi.html
“P代码似乎没什么优点喔，我唯一知道的就是编译为P代码较难破解”

“在应用OLLDBG调试VB P-CODE代码时，我们应该注意几点：
一般VB中的使用的局部变量位置在内存中是不确定的，这次调试和上次调试的同一变量位置基本是不同的，是动态产生的，所以，不要象调试其他C编译或汇编程序那样，下一个固定的内存断点去发现某些变量的变化（仅仅是个人意见，不一定对）。”


“VB P-CODE编译的程序运行时，在主要流程中，通常ESI寄存器指向相应的VB p-code伪代码。 所以，调试时，最好同时打开相应程序的P-CODE伪代码（例如运行VBExplorer,并打开相应的程序。为了便于分析，可以是同样程序的拷贝副本），以供参考，查看程序的实际流程。
”
“通常，vb 程序运行在虚拟机（MSVBVM60.DLL）中 ，因此，当您使用OLLDBG打开一个vb p-code程序后，应该在菜单中选择“【view】”选项，然后再进入选择“Executable modules”, 并在其中的“MSVBVM60”行上，点击鼠标右键，然后选“view name”。如此，可以直接查看VB运行库中的函数名，查找有关的函数名，在常用的函数名上点击，并设置断点。”



当程序中断在您设置的断点后，你可以逐步跟踪程序了，为了把握住程序的流向，您要时刻关注ESI值的变化，它通常在40xxxx范围内，它明确地指向VB P-CODE伪代码的流向，你不用担心不知道自己所在的位置。你可以随时切换到VBExplorer中，看看程序到底跑到哪里去了。

在您调试的过程中，您会发CALL AX，应该单步跟进去，它通常会带你返回那个正被调试的VB程序主域（或叫“领空”，学台湾人的说法），一般附近是一些JMP长跳转，这些是程序中需要调用函数，应该给予重视，可以尝试在相关函数上下断点。

当您看到call bx时，通常程序要调用真正的函数执行功能，你应该跟进去，一般在执行P-CODE比较伪指令的过程中，你会发现一个call bx，一定要跟进去，通常会它引导你看到真正的注册码以及你输入的假注册码进行比较。通过观察堆栈的显示，你就可以看到他们，两个可爱的字符串(通常出现在OLLYDBG的调试窗口的右下方)。

关于最后的修改VB P-CODE代码，暴力破解法，据我所知一般只要能将重要的转移指令改变就可以了。无非是在您选好的比较指令的位置将BranchF（伪代码1c）BranchT(1d) 或者Branch(1e)改来改去。





125.P-code,实际上是一组自定义的指令集,必须通过基于堆栈的虚拟机翻译为80X86上的指令集才能执行,即通过msvbvm50.dll和msvbvm60.dll这两个动态库来解释执行。也可以理解为通过P-CODE告诉虚拟机将要进行什么操作。
126.4c法同样适用于P-code编译的程序
127.甄别一个VB应用程序是不是以P-CODE方式编译的,一般有两步:1:看代码段中入口点以下是不是大片的字节码 
							  2:看有没有MethCallEngine这个函数。
128.【指令】：【sete cl】：设置指令，根据zf(zero flags)标志位来设置cl的值。即是如果zf=1，则cl等于1,否则等于0
129.【寄存器STO】寄存器窗口中STO：浮点寄存器

第三十章：
130.依然是【OD注意事项】：上一章说可以用原版打开上个教程中程序，但加载.ini就不行，在这章中我调试了下插件问题，发现只要取消掉【插件-HideOD-option-ZwSetInformationThread】前面的勾就可以运行本章中的程序和上一章中的程序（可能之前不能用52OD运行的程序都和插件有关，所以下次碰到无法运行的程序，比如医用52OD打开程序就显示已终止，就可以试试更改插件选项，或者完全取消反调试的插件）
131.关于操作码其他的文档在本目录下的P-CODE
132.【方法】：有时候，OD中某处显示的函数不一定就光调用一次，所以如果要防止还有其他地方调用这个函数，可以在这条指令上右键Follow定位到这个函数的入口点，在入口点处也设置一个断点
133.P-CODE代码我们不能像常规的汇编指令那样直接NOP掉。
134.在替换P-CODE操作码的时候必须保证新的操作码与原操作码参数所占大小相等，如果参数大小不匹配的话，那么替换以后，程序很有可能出错


**************脱壳篇***************

第三十一章：
壳的种类：压缩壳，加密壳，虚拟机壳（为什么要加壳：一个未加壳或者脱过壳的程序修改起来很方便,但是如果一个加过壳或者自修改的程序,要想修改它就比较困难了,我们在入口点(PS:这里指的入口点是壳的入口点)处修改程序是不起作用的,只有当壳把原程序区段解密完成后修改才能起作用。）加过壳的程序,原程序代码段通常是被加密过的,我们想修改它就不那么容易了。加壳程序给目标程序加壳的原理通常是加密/压缩原程序各个区段,并且给目标程序添加一个或者多个区段作为原程序的引导代码(壳代码),然后将原程序入口点修改为外壳程序的入口点。
135.加过壳的程序（这里说UPX）其实就是一个循环，逐字节读取加密过的字节，接着进行数学运算（例如说：加法，乘法，等等）来解密，云心个完毕得到院士字节值，然后将其恢复到原处。

加过壳的程序执行的整个流程（现在的一些强壳已经不能这么简单概括了）
	1.执行解压/解密例程
	2.解压/解密原程序的各个区段的数据
	3.跳往OEP处
	4.执行原程序代码
136.加壳后的程序使用OD修改代码是不能直接保存到文件的。
	如果执意要修改的话，可以使用十六进制编辑器将401000对应的数据修改为90 90，然后用OD加载该修改过的程序，接着来到401000处，可以看到是90 90开头，然后紧接着全是00，当解密例程开始解密时，会将解密后的院士的6A 00 再次填充到401000处，当解密区段完成并跳往OEP后，依然执行的是6A 00 而不是90 90，也就是说我们所做的修改将被解密例程覆盖掉了。
	也就是说，如果你想修改这些字节的话，你需要定位到读取加密后字节的地方，在其解密出原始字节时，将其修改掉，这样才能成功修改这些字节，但是如果这样弄的话，需要做的工作太多了，大家吧这个过程理解为文件补丁，如果待打补丁的程序被加壳，压缩或者有自校验，则补丁就不会被顺利利用。正因为有了如此不变指出，所以，在文件补丁技术以外，还有一种更加高阶，隐蔽的方法，也就是内存补丁。
	内存补丁的总体思想就是在某个时刻（解压，校验或某种情况发生以后），在目标程序的地址控件中修改数据，因此也被称为Loader，每次使用时都需要调用程序运行。（内存补丁可以参考《加密与解密》）

第三十二章：
137.OEP在99%情况下位于第一个区段中，但也有不是的。
138.当到达OEP后，各个区段在内存中的分布跟原始程序很接近，这个时候我们就可以尝试将其转储到（dump）文件中，完成程序的重建工作（PS：脱壳）。
139.脱壳的基本步骤如下：
	1.寻找OEP
	2.转储（DUMP）
	3.修复IAT（修复导入表）
	4.检查目标程序是否存在AntiDump等阻止程序被转储的保护措施，并尝试修复这些问题。
	（具体到不同的壳的话会有细微的差别）
140.*******************************************************************
    【方法1】：搜索JMP(0E9)或者CALL(0E8)指令的机器码（即一步直达法，只适用于少数壳，包括UPX，ASPACK）
	除了搜索JMP指令的机器码以外，还可以搜索CALL EAX  ，CALL EBX ,JMP EAX等指令的机器码。因为很多壳是将OEP的值存放在寄存器中，然后通过CALL 某个寄存器或者JMP某寄存器来跳往OEP的。
	OD提供了搜索ALL commands的功能。（右键――查找――all commands）如果存在输入要搜索的指令的话，那么会在一个列表里面全部显示出来，然后在每条记录上右键设置断点，当断下来的时候，可以看EAX的值为多少，根据EAX的值来确定是不是CALL或者JMP转移到第一个区段中。
（但这种方法不常用，因为现在的壳的解密例程都具有自修改功能，特别对于跳转到OEP这样的指令通常都是做了隐藏处理的，只适用于简单的壳）
    【方法2】：使用OD自带的功能定位OEP（SFX（Self-extracting files（自解压文件））法）
	打开Options-Debugging options-SFX。
	Trace real entry blockwise(inaccurate)和Trace real entry bytewise(very slow!)这两个选项就是OD用来辅助定位OEP的，前者定位速度快，后者慢但精确（因为是按字节来定位的）
	但这两个选项只有当OD发现入口点位于代码段之外的时候才会起作用，而（crackme （加了壳））这个程序的入口点恰恰是位于代码段中的，所以OD的这两个选项不会起作用。
	（壳的入口点位于代码段中的情况还是比较少见的）
 【注意】：在使用完这2个蒜香以后记得要恢复默认的选项，如果不恢复的话OD在分析其他程序的时候就不会停在正确的入口点了。
    【方法3】：用Patch过的OD来定位OEP（即内存映像法）
就是用专用OD，即正常的内存访问断点读取，写入，执行的时候会断下来，该专用OD内存访问断点仅当执行的时候才会断下来，可以利用这一点来定位OEP。
	UPX壳的解密例程会解密源程序的各个区段并将各个区段原始字节写会到原处，我们最好不要在解密区段的的过程中断下来，说不定要断成千上万次才能到达OEP，有了这个专用的OD就方便多了，其内存访问断点仅当执行的时候才会断下来，当其在执行第一个区段中的代码时，基本上就可以断定是OEP了
	具体执行步骤：【M】――在401000处设置内存访问断点，勾选上忽略各种异常的选项（【PS】：在这里，这个专用OD打开UPX crackme的时候，没有直接断在壳的入口点，而如果要像之前那样回到入口点，需要先按F9，但是如果直接按F9，调试就会终止。解决办法：先不要忽略各种异常（其实只要不忽略single-step break ），再按F9，回到壳的入口点后，再忽略各种异常，然后在【M】中给401000设置内存访问断点，之后再运行起来就是可以到达真正的OEP。）	然后运行起来。
	但是有可能会碰到像UnPackMe_ASPack2.12这个程序的情况：按照上面的步骤实施以后，确实断在了401000上，（这里401000是个retn），但是F7返回后却发现返回到了壳的解密例程中，当再次运行起来，程序就直接运行了。  
	【原因如下】：因为这里壳的解密例程并不是将代码段解密到第一个区段中，所以我们可以继续给后面的区段设置内存访问断点，逐一排查。如果弹出运行窗口就表示该程序在内存中解密区段完毕了，源程序的代码得以执行。所以这里依次给各个区段设置内存访问断点，然后运行起来，如果程序直接运行起来了，就证明这个区段不是我们要定位的，继续给下一个区段设置内存访问断点。这里在给第三个区段（404000）设置内存断点时，运行后断在了404000，可以看到断在了OEP处，如果不确定是否真的是OEP，继续运行，会发现断在下一条指令处，可以进一步断定这里是OEP了
	这种方法对很多壳都有效。
――――
更新：用patchOD的话速度太慢，其实也可以用手动的原理：这里参考ximo教程中的笔记，二次内存镜像法（区段下断的顺序等）
还有这种方法上面也提到了一点，有的OEP可能不在第一区段，需要用patchOD对剩下的区段逐一排查
    【方法4】：堆栈平衡法（即ESP定律法）（适用于古老的壳，这些壳首先会使用PUSHAD指令保存寄存器环境，在解密各个区段完毕，跳往OEP之前，会使用POPAD指令恢复指令寄存器环境。有的情况下，保存寄存器环境可能不是一条指令，但也在附近，还有些情况下，有些壳不适用PUSHAD，而是逐一PUSH各个寄存器，总而言之，在解密完区段，跳往OEP之前会恢复寄存器环境。）
	具体执行步骤：先F7，让各个寄存器的值入栈，然后通过右击ESP（注意是ESP，但不知道是什么原理）――在数据窗口中跟随，就可以定位到各个寄存器的值（一共8个寄存器），然后对这些初始值的第一个字节或者前4个字节设置硬件访问断点，选择字节，字，双字都可以，只要解密例程在读取这些值的时候断下来就OK，运行起来。就可以看到断在了POPAD指令的下一行，紧接着下面会有个跳转指令，单步运行过去，那里就是跳往OEP处。
	（这里要说明一点：现在很多壳都能检测这种方法，所以说可以多多汲取一些方法和经验，才知道哪种方法最合适。）
	还有一点：有的壳的PUSHAD不在壳的入口点处，所以拿到壳要先观察一下壳，有可能在壳的入口点附近（例如bitarts_evaluation这个程序就是这样（如果在执行的时候有误，试试勾选忽略各个异常））

更新：看了Ximo教程，发现ESP定律可能会有不同的情况：首先关键入栈可能并不是PUSHAD，例如PEcompact这个壳，关键入栈是push eax,和push fs[0],而且并不是F9后就能直接或者单步几次就能到达OEP，PEcompact就需要单步多次
    【方法5】：VB应用程序定位OEP法（Native或者P-code）
	定位VB的OEP比较容易，以为VB程序都有一个特点：一开都是一个PUSH指令，接着一个CALL指令调用伊特VB API函数。可以使用专用OD，首先定位到VB的动态库，接着给该动态库的代码段设置内存访问断点，当壳的解密例程解密完原程序各个区段，接着就会断在VB DLL的第一条指令处，接着我们可以在堆栈中定位到返回地址，就可以来到OEP下一条指令处。
	这里我们也可以使用前面介绍的方法：跟逐一给各个区段设置内存访问断点（用专用OD），但是很多壳会检测这种方法，所以需要根据不同情况来尝试这种不同的方法。
	
    【方法6】：最后一次异常法（如果在脱壳过程中发现目标程序产生大量异常的话，就可以使用这个方法，）（更新：这里指的大量异常可能是在同一个地址出现大量异常：如这章讲到的程序，在Address一栏在某个地址重复出现了异常，注意这里的异常地址是日志窗口的Adress一栏，不是Message栏里的地址,而且最后一次异常法最后一次异常法，顾名思义就是最后一次异常，要在日志中找到最后一次int 3异常）
	
	具体执行步骤：先用专用OD加载程序，并且忽略各个异常，然后打开日志窗口（【PS】：如果在日志中看到有好几处异常，但都不是第一区段的，说明这些异常不是在原程序运行期间发生的，是在壳的解密例程执行期间产生的异常），
	然后重启OD，取消勾选所有异常除了ignore memory access violations in KERNEL 32，运行起来后 shift F9忽略日志中所有异常（最后一次异常的地址可以在上一步中找到），然后再对代码段（这里好像第一区段代码段）设置内存访问断点（问题：为什么不在一开始设置内存访问断点？原因：因为很多壳会检测程序在开始时是否自身被设置内存访问断点，如果执行到了最后一次异常出的话，很可能已经绕过了壳的检测时机），然后shift F9 运行起来就可以看到OEP（需要配合日志，shift +F9 的时候如果日志中显示了断在了内存断点，那么这个时候断的地方应该就是OEP）
	壳会检测内存断点，所以这样所还是很有必要的。
	在离OEP越近的地方设置内存断点，就越不容易被壳检测到。
(这里说可以直接通过对代码段设置内存访问断点，过一段时间就能到达OEP，但是用所有版本的OD或者用虚拟机好像都没有这个现象

更新：在这里只有用原版的OD才能看到异常，用教程中说的专用OD和52OD都不能看到异常（包括虚拟机中）
    【方法7】：利用最常用的API函数来定位OEP
	壳最常用的函数：比如GetProcAddress LoadLibrary。ExitThread有些壳会用
	【GetProcAddress】：检索指定的动态链接库(DLL)中的输出库函数地址
	具体执行步骤：用专用OD打开程序，给GetProcAddress设置断点，运行起来后断了下来（这里不需要其断下来，我们只需要知道在哪些地方调用了GetProcAddress），然后对它设置条件断点（conditional log），Pause program勾选Never，记录的表达式设置为[ESP]，也就是记录返回地址，这样就可以知道哪些地方调用了GetProcAddress,（然后这里清空日志窗口），运行起来，在日志窗口中看最后一次GetProcAddress（排除掉第一个区段中调用的位置）是在哪里被调用的。（按教程中的意思应该是看日志窗口中哪些地址是大量且连续地在被调用，在这个例子中，可以看到47009A这个地址大量且连续地出现），所以要定位的应该是47009A这一处。
	所以重启OD，重新编辑条件断点，条件设置为[esp]==47009A,Pause program勾选On Condition，然后F9，就能断在GetProcAddress函数处。
	（*在对代码段设置内存访问断点之前尝试一下这种方法，这样就可以绕过很多壳对内存断点的检测，但是有一些壳也会对API函数断点进行检测，所以说需要各种方式都尝试一下，找到最合适的）
	对当前这个壳定位GetProAdress的调用处是可行的，执行上述的方法后，就已经在OEP附近了，然后给代码段设置内存访问断点，多次F9就能到达OEP（*这个程序中，当到达入口点后，程序并没有直接显示汇编代码，而是一些数据信息，这里分析后才能出现正确代码，但是如果删除分析，却又回不到那些数据信息，这不知道为什么）。（如果定位GetProAdress的调用处失败的话，可以换其他的API函数），然后查看日志窗口，可以看到一处线程结束的记录
	当给ExitThread设置断点，将菜单项Debugging options-Events中的Break on thread end(在线程结束位置中断下来)勾选上。运行起来后断在了线程结束的位置，然后给代码段设置内存访问断点就能定位到OEP
	（在这个例子中，当断在条件断点之后，需要按非常多次的F9，才能到达入口点）
（用虚拟机时记得修复路径）

    【方法8】：利用应用程序调用的第一个API函数来定位OEP
	这种方法就是直接给应用程序调用的第一个API函数设置断点，比如说，很多程序（VC++）一开始会调用GetVersion，GetModuleHandleA，对于bitarts_evaluations.c这个程序来说我们可以断GetVersion ，对于CRACKME UPX来说可以断GetMoudleHandleA。
	具体执行步骤：（拿bitarts_evaluations.c做示范）BP GetVersion，断在了这个函数的入口点处，从堆栈中我们可以看到返回地址位于第一个区段。在反汇编窗口中跟随，就可以看到我们又定位到了OEP的附近。
	如果遇到有的壳检测GetVersion入口处的INT 3断点的话，我们可以尝试在该API函数的返回指令RET处下断。
********************************************************************
141.如果壳检测INT 3断点或者硬件断点的话，你使用ESP定律给堆栈中的寄存器初始值设置硬件断点也是不起作用的，只能换其他方法。

第三十三章：
142.操作系统动态库版本的更新，其包含的API函数入口地址通常也会改变。比如USE32.dll
143.IAT：import address table（输入函数地址表）
144.【设置】：调试选项――反汇编――显示符号地址。将CALL <JMP.&USER32.MessageBoxA>显示为CALL 40143A
145.windows操作系统当可执行文件加载到进程所在内存空间中时，会将正确的API函数地址填充到IAT中
146.操作系统可以根据字符串指针定位到相应的API函数名称，然后通过调用GetProAdress获取对应API函数的地址，然后将该地址填充到IAT中。
	（PS：这里4031AC被填充了正确的message函数入口地址，这个地址是怎么来的：4031AC中保存了正确的入口地址，选中这4个字节，就能看到对应于可执行文件中的文件偏移是多少，这里文件偏移是3360，而403360中保存的就是messageboxa函数的函数名称，然后操作系统会通过getproadress函数来获取messageboxa函数的地址，然后填充到IAT中，这就是4031AC中77D504EA这个正确的函数入口地址怎么来的过程）
	（PS：有时候像DUMP后但未修复IAT的crackme，虽然在IAT中已经填充了正确的API函数地址，但是想要正常运行再其他机器上的话，必须要指向各个API函数名称字符串的指针，这样才是确保操作系统能够通过GetProAdress获取到正确的API函数地址并填充到IAT中。但这里该dumped.exe缺少这些指向API函数名称字符串的指针，所以运行的时候会发生错误。）
	（像dumped.exe中如果定位到4031AC，虽然里面保存了正确的函数入口地址，但是无法查可执行文件，所以说这是未修复IAT的程序）
147.为了确保操作系统将正确的API函数地址填充到IAT中，应该满足
1：可执行文件各IAT项所在的文件偏移处必须是一个指针，指向一个字符串。
2.该字符串为API函数的名称
如果这两项满足，就可以确保程序在启动时，操作系统会将正确的API函数地址填充到IAT中
148.dump：意思是把内存中正在运行的 PE 整个抄下来，储存成另一个 exe file。这种做法可以把程序执行的某一刻保留，例如在 IAT 建立完成后。dump 是脱壳的一个基本步骤.（工具：LordPE）
149.【关于LordPE】：win7 64位无法正常运行此软件（这个软件只能读取60个进程）。在XP虚拟机中可正常运行。解决方法：看雪的增强版LORDpe
	用LordPE的时候，需要Dump的程序需要在脱壳后的OEP处
	LordPE使用的时候先定位到已经处在OEP的程序，然后右键active dump engine-IntelliDump-Select!接着选择dump full。
	不要DUMP出来再回复IAT，应该先回复IAT在DUMP出来
150.在PE中可能会看到IT（import table）
    IT=Import table=导入表
    IAT=import address table=输入函数地址表
	（函数导入表一般是20个字节为一组IID）
	（PE头中可以查看到导入表的大小，即导入表的结束地址）
	（一般对cracker来说只对IID的第4、5个字段感兴趣）
	（第4个字段Name1含义：指向DLL名称的指针
	  第5个字段FirstThunk含义：指向的链表定义了针对Name1这个动态链接库引入的所有导入函数）

151.大量实验表明：IAT不一定位于导入表中。IAT可以位于程序中任何具有写权限的地方，只要当可执行程序运行起来时，操作系统可以定位到这些描述符结构IMAGE_IMPORT_DESCRIPTOR（IID）项，然后根据IAT中标明的API函数名称获取到函数地址即可。
	操作系统填充IAT的具体步骤：
	1.定位导入表
	2.解析第一个IID项，根据IID中的第4个字段定位dll的名称
	3.根据IID的第5个字段DLL对应的IAT项的起始地址
	4.根据IAT中的指针定位到相应API函数名称字符串
	5.通过GetProAddress获取API函数的地址并天虹到IAT中
	6.当定位到的IAT项为零的时候表示该DLL的API函数地址获取完毕了,接着继续解析第二个IID,重复上面的步骤。
(在数据窗口中定位某个字节，查看可执行文件，对应的数据是RVA相对虚拟地址，真正的地址是基址加相对虚拟地址，即400000+RVA)
	
152.【工具】【52OD中的插件】：插件――ollydump――脱壳在当前调试的进程
	（关于dump 和 anti-dump 可详见https://bbs.pediy.com/thread-17624.htm）
153.有时候需要定位到IAT表（不是指在数据窗口中的IAT表，而是反汇编窗口中的IAT表）像此教程中一些程序的IAT表都在程序结尾处（当时是要在脱壳后），如果不在程序结尾处，就可以直接搜索二进制FF25就可以快速地定位该跳表（因为这些跳转指令都是以机器码FF25开头的）
	（PS：其实，并不是所有的程序都通过这种间接跳转来调用API函数的，所以直接搜索FF25这种方法有时候会失败，而通过定位某个API函数的调用处，然后Follow到跳表这种方式才是一直有效的）
	（2进制搜索方法：右键――查找――二进制字串 ctrl+b，ctrl+L查找下一个）	
154.可以通过跳转表中最小的地址和最大的地址算出IAT的起始位置和结束位置，比较好的做法是，直接将数据窗口往上滚动，我们知道IAT的每个元素中都保存了一个API函数入口地址，比如这里的764E1245，属于同一个动态库的API函数地址都是连续存放的，不同动态库函数地址列表是用零隔开的。（在764E1245后就可以看到有几行是零隔开的）
（有一些壳会将这部分全部填零，使得我们的IAT重建工作变得困难）
	（PS：每个用零隔开的部分他们的数据都是相同的，比如这里的76XXXXXX,71XXXXXX,75XXXXXXXX...于是我们就可以通过【M】窗口查看这些76XXXXXX,71XXXXXX,75XXXXXXXX...开头的函数都是属于哪个DLL。如这里的76XXXXXX属于Kernel32,71XXXXXX属于comctl32，75XXXXXX属于GDI32...如果某个地址上面全是00000000，那么就表示IAT的其实地址就是零下面，下面就是存放了IAT中的第一个元素。PS：有些强壳可能会将IAT前后都填充垃圾数据，让我们定位IAT的起始位置和结束位置更困难，但是我们知道IAT中的数据都是属于某个DLL代码段范围内的，如果我们发现某数值不属于任何一个DLL的代码段的话，就说明该数值是垃圾数据。）
	（通过上面的方法就可以知道IAT的起始地址，然后定位IAT的结束位置：结束位置的查找跟起始位置的查找相同个：往下滚动，看到数据都是00000000，那么00000000上面就是IAT的结束位置）
*******************一下是Import REC的使用具体过程（先用OD定位到OEP，然后选中正在调试的程序，这里就不再重复了）
	Improt REC重建IAT需要三项指标：
	1.IAT的起始地址,这里是403184，减去映像基址400000就得到了3184（RVA：相对虚拟地址）
	
	2.IAT的大小:40328C-403184=108H(注意这里起始地址和结束地址不要弄错了,开始地址是从00000000后面的第一个地址,结束地址是00000000第一次出现的位置,不是结束地址的位置)

	3.OEP=401000(虚拟地址)-400000(映像基址)(这个映像基址可能是【M】中的第一个PE文件头的地址)=1000(OEP的RVA)
	然后点击Get Imports（这里又出现了不兼容的问题：win7 64 在这步之后会出现两个Valid：NO，虚拟机XP则正常）如果继续按下面的步骤修复，会提示错误，所以在修复IAT的时候不能有Valid ：No的情况。
	然后点击Fix Dump，选中之前DUMP出来的文件。
	双击修复后的文件，还是不能运行（这是正常情况，通常修复IAT后都会出现这种情况）
	于是打开PE Tools――tools――rebuil PE，打开刚刚修复后的文件，重建。完成
	然后用OD打开重建后的文件，OD会提示入口点位于代码段之外因为UPX壳将代码段指定到了第三个区段。现在要修复这个问题（如果用52OD不会弹出这个提示窗口，原因不详，可能是哪个插件，但是原版OD还是会提示所以下面分2种情况，看看区别）：
	先是52OD：载入后没有提示入口点在代码段之外，但继续执行教程中的步骤：在数据窗口中定位到400000，切换为PE模式，看到Base of code=9000，我们需要将代码段的虚拟地址修改为1000，选中baseofcode这一行，右键――modify integer（修改整数），修改为1000，修改保存到文件（注意这里之前提到的，右键是在数据窗口右键，在不同窗口右键会有区别，这里再次提醒）。再次加载修复好的程序，可以看到没有警告窗口了（这是对原版OD来说的，52OD两次打开2个程序都没有区别）
	然后是原版OD：执行步骤和上面一样，不在赘述。
	（这样看来2者好像没有区别？）（我在看雪这章教程中提了问，为什么52OD自动修复了这个问题?2017.11.12  	答：	）
	
	再次加载修复过的程序，【M】窗口中多了一个区段mackt，这是Import REC给该程序添加的一个新的区段，专门用来存放新的导入表的。


	（有些壳会将IAT重定向到壳的例程中，然后在跳转到api函数的入口处，这样的话，上面这样定位IAT的起始和结束位置的做法就行不通了。如何应对这种情况：（后面介绍：三十六章））	

第三十五章：
*************ASPack壳
154.有时候来到入口点后，代码被翻译成了数据，分析代码即可，但是有时候代码解析不够完整，这时候需要再次分析代码。
155.ASPack加壳程序的源程序代码段并不是第一个区段，而是第三个区段
156.【插件】OD插件自带dump功能，并且这个dump插件还带修复IAT的功能。
157.并不是所有程序都是通过间接跳转来实现调用API的，这章中的程序就是这样。（这里是通过一个间接CALL来调用API函数的）
158.右键――查找――所有模板间的调用，可以看到程序使用哪些DLL，像这章中的程序就用了3个DLL，kernel32、ntdll、use32、但是通过数据窗口中的数据和【M】中的对比，发现IAT中只调用了kernel32和user32，IAT中没有ntdll。解决方法：在模板中随便找一个NTDLL的API函数调用处，发现有几项和kerner32.dll的AIT项混在了一起。
159.在用import REC 的get import的时候可能会出现 Valid NO的情况，这和之前说的修复错误是两种情况，这里的这种情况是因为在IAT中有垃圾数据，所以会出现valid no
160.剔除掉垃圾数据：点击+号将其展开，点击show invalid，右键cut thunks（剪切掉），Fix Dump。（但是重定向过的IAT也会显示Valid NO，这些项需要修复，见第三十七章的笔记）


第三十六章：
************bitars 5.0壳和telock 0.98壳
biatars_evaluation无法用52OD定位到OEP，这里选择了原版OD
161.判断是否为OEP：来到第一个API函数处，给该函数设置一个断点，运行起来，接着就会断下来，看看返回地址是不是位于第一个区段，如果是就定位到返回地址处，上面就是OEP了。
162.各个DLL的IAT项被零隔开（这个之前提过，这里再提一下。）
163.【方法】：选中IAT中的某一项，右键――find references就能快速看到这部分IAT属于哪个DLL以此来代替在【M】中查询
164.在查看IAT的时候有可能IAT会很大，而且开始和结束处不会像之前那样有很多零，一眼就能看出哪里是开始，哪里是结束，但是也很好判断。像这章中的例子，在IAT结束的时候首先会有一个字节的零隔开，接下去没有很多的零，但是很明显能看到接下去存放的都不是IAT，如果怀疑下面有可能还是IAT项，那么继续find references，看到列表为空，则说明下面的数据不是IAT项。（但也有可能会是IAT重定向的，见下文166）
（这里再提一下IAT的开始地址和结束地址：开始地址是指IAT第一个字节的开始处并不是像结束地址一样第一次出现零的地址）
165.在用最后一次异常法的时候，可能不会像教程中那样运行起来后直接能在日志窗口中看到最后一次异常断再哪里，（这个不知道是什么问题，可能是OD插件或者设置问题），解决方法：这时候日志没有全部结束，就多次shift+f9直到日志窗口不再跟新，这个时候就能看到教程中说的最后一次异常了（最后一个illegal instruction的位置就是最后一次异常的位置）（然后重新运行，shift+f9一直运行到最后一次异常的地方给第一区段代码段设置内存访问断点，shift f9运行起来）（方法6）
166.
  在IAT中如果某些find reference中显示了一些诸如：DS:[...]=[...]的情况，这些其实是一些指针，这并不是调用某个系统DLL中的API,二十IAT中重定向的一些项，当程序运行起来时，壳的解密例程会覆盖掉IAT中的某些项，将这些项重定向到解密例程中。
	（PS：如果有个区段是标位Private，并且当程序断在入口点处时不存在，则这个区段就是在解密例程中创建的）
	（可以查到这块内存块是什么时候被创建的：给VirtualAlloc函数设置断点，这个函数是用来申请空间的，忽略异常的选项都勾选上，按shift+F9运行起来，如果程序直接结束，说明壳会检测我们设置的API断点，只能讲断点设置VirtualAlloc的RET处，运行起来，断了下来，记录EAX的值，继续运行，现在可以在【M】中看到刚刚创建的这个内存块。）
	IAT中存的这些新内存区域将API重定向：通过PUSH指令将API地址压入堆栈中，接着RET将会返回到API的入口处，这样就可以达到间接调用API函数的目的（也就是说壳会将API的IAT项替换成自己创建的内存单元中的地址，起到一个重定向的作用）因此我们在定位IAT的起始和结束位置的时候，不仅仅要判断是否为系统DLL中的地址，还需要判断其是否为重定向过的地址。
	这时候在IMP rec中输入3要素，点击get import，IMPrec会检测到重定向的项（显示为valid no），于是就要修复重定向的IAT（见下一章）

第三十七章：（手工修复IAT）
167.【OD】【trace into】【ctrl F11】：OD有一个自动单步跟踪的功能，我们用这个自动单步跟踪的功能可以方便定位到重定向过的IAT项对应的API函数入口地址，重定向过的IAT项单步步入5,6行就可以定位到其对应的API函数
	具体执行步骤：
	【方法1】：在函数调用处call的返回地址处即下一条指令处设置一个断点，由于OD的自动跟踪功能是不会主动停止的，我们应该设置自动跟踪停止的条件。debug――set condition。打开【M】查看EIP指定什么范围比较合适：当EIP位于主程序的区段或者壳创建的区段中，我们让OD自动跟踪，OD跟进到DLL中的时候，我们需要OD停止跟踪，所以这里我们将范围设置为5D170000~7FFFFFFF（是对这章中的例子而言的）（当OD自动单步跟踪，当EIP位于任意一个系统DLL的区段中的时候就会停止跟踪），对函数CALL指令处和call下一条指令也就是返回地址都下一个断点，（这里要记得把之前用于定位OEP的内存访问断点删除），再给所选的IAT项设置4个字节的内存访问断点，先运行起来断在第一个断点处后再ctrl f11.然后可以看到OD的下方的提示信息，断在了设置的范围内（如果不是，则忽略异常继续运行）。
	接下来的工作就是检查调用完API函数以后是不是返回到我们刚刚设置了断点的返回地址处，因为有些壳会调用多个API函数来混淆视听，前面调用的几个API函数都是用来迷惑我们的，最后一个API函数才是真正要调用。这里我们可以看到堆栈窗口显示的返回地址正好是我们设置了断点的那个返回地址4271DC。现在停在API函数的入口处，但是OD这里并没有提示API函数的名称，需要确定的是哪个API函数，现在来分析一下DLL的代码，右键――分析代码，在解释窗口中可以看到该API函数的名称为Kernel32.Getversion，EIP中也显示函数的名称（我这里没有显示，而是显示了一个地址）
	（*PS：对于不同的IAT项，只要找到CALL [46......]这样的地址，然后重复上面的方法，就能手工修复IAT了，但要完整修复，还有很多问题没有解决，见《问题》24。）
	【方法2】：接下来看下一个自动跟踪终止的条件选项EIP is outside the range，通过设置这个选项我们也可以定位到其要调用的API函数：将这个选项设置为401000~1272000（这个1272000是怎么来d?），即当EIP超出了主程序所在区段的范围就会停止自动跟踪。（这个教程中也没详细说明，就给了这个过程）
	【方法3】：还有一种情况：少数壳会将区段创建在系统DLL的区段之间，这样的话，需要用到Condition is True（当条件成立时）这个选项了：这里搜索EIP指向的指令为RET，并且栈顶指针指向的是4271DC的指令。这两个条件同时满足我们可以使用&&，||相当于OR。所以自动跟踪条件设置为【ESP】==4271DC && byte 【EIP】==0C3（RET的机器代码）。然后trace into，就能定位到API函数的返回指令RET处，这里我们由于并不在该API函数的入口地址处，所以OD并不会提示该API函数的名称，解决方法：工具栏中【...】按钮查看自动跟踪的日志信息。分析代码，在日志信息的第11行处（为什么是在第11行？这也是个很严重的问题。答：因为会断在retn处，所以看retn这里的地址是什么，然后在【...】中找到该地址，然后找这处地址的上一个地址，继续执行下面的步骤）双击，EIP上显示了函数的名称。
	有些壳会去模拟执行API函数前几条指令，然后再去指令API函数后面的代码，这样OD也不会提示该API函数的名称，解决方法：在API函数返回指令ret的下一行指令空白处单击空格键，CALL 我们怀疑的API函数入口地址，这里我们输入：call 7c81126a，就可以看到OD提示API函数的名称为Kernel32.getversion。如果我们CALL的不是API函数的入口地址的话，OD就不会显示函数名称了
alt+bksp：撤销刚刚所做的修改。
――――――――――――上面就是如何手工定位API函数的名称。
――――――――――――下面对需要重定位过的IAT进行修复：
打开IMP REC，在60ADC上双击左键，在弹出的窗口中选中API函数所在的模块以及其函数名称。60ADC对应为kernel32.dll、GetVersion
另一种修复方式就是直接在重定向过的IAT项中填充正确的API函数地址：在460ADC这一项上填入GetVersion函数的地址，（我的入口地址为7C81126A）
对于其他的重定向过IAT项我们也可以按照上述方法来进行修复，接着就可以修复DUMP文件了（剩下的就是体力活了）
  IMP REC提示了一个功能可以协助我们完成这个手工修复工作。单击save tree，保存修复过的IAT项，当下次项继续修复其他项的时候可以通过单击Loda Tree按钮导入我们之前保存的IAT信息。
  还有一种修复重定向IAT项的方法就是借助于IMP REC的插件【tELock1】：同样输入三要素后，get imports ――show invalid――右键――Plugin――tracers-tELock1，这样插件就会帮我们修复这些重定向的IAT项，在日志窗口中可以看到有4项没有修复，需要我们自己修复。这个插件只能针对于特定的壳
  IMP REC还自带常规的Tracers，我们可以试试看，。通常他可以代替我们完成手工修复任务：在第一个修复失败的项上右键――3个等级中选择Trace level（Disasm），如果失败了，继续尝试下面2个等级。如果不能修复，只能手工修复（但是手工怎么修复无效指针，即find reference表中是空的怎么修复？见《问题》24）
	（Search for-All intermodular calls可以查看所有API函数）
	（重定向修复就是要找函数的正确入口地址，因为IAT中的新内存区域将API重定向：通过PUSH指令将API地址压入堆栈中，接着RET将会返回到API的入口处，这样就可以达到间接调用API函数的目的（也就是说壳会将API的IAT项替换成自己创建的内存单元中的地址，起到一个重定向的作用））
	【方法4】：关键跳法（这种方法就是定位壳填充IAT的时机，看看何时填充正确IAT项，何时填充重定向过的IAT项。）
	①这里用GetVersion做例子：给【460ADC】设置硬件写入断点，这里如果设置断点运行起来后程序直接终止了，说明程序会检测硬件断点会直接退出，于是可以给【460ADC】设置内存写入断点，注意*，这里是内存写入断点，是Memory on write，而不是memory on access。（好像需要忽略所有异常再进行），断下来的地方不一定对，（可验证，如果F8后，IAT项没有被写入进去）这里不是正确的地方，继续运行，多运行几次，中间可能会遇到写入IAT的时候，但是要对比是否是到达OEP后的IAT项，多运行几次，运行到串写入指令时停下观察，直到来到正确的地址，这里运行到 MOV ...,ECX这条指令的时候，发现ECX和IAT项中的值相同，说明这里就是我们要定位的地方。
	②接下来要定位关键跳转，往下跟几步会出现GetVersion在接下来定位中会看到call GetProAdress函数来获取GetVersion地址，F8执行这个CALL，下面会有一个跳转条件，Follow进去会看到API被重定向到EDI所指向的单元中，而EDI这是指向了到达OEP时的地址，紧接着又到了一个JMP指令，通过这个JMP指令将回到这个过程的开始处，循环往复，直到所有IAT都被处理完毕。（但壳只是对一部分IAT项进行重定向）
	壳对IAT项重定向以及不重定向流程的差异：这种地方需要分析代码。
	
	下面详细对①②和这个程序如何对IAT项重定向和写入正确IAT项做解释：
		还是拿GetVersion 这个API做例子：
		到达OEP后 附近的一个调用是	CALL [460ADC]
						460ADC里存的是9E06F7
						也就是说 CALL 9E06F7
						9E06F7处的代码执行内容是：生成一个地址，并调用这个地址中的内容，这里调用的是[9E17D4]
						而[9E17D4]=7C81126A也就是GetVersion的正确IAT项（可以说达到了一个间间间接调用的目的）
		而这个方法的目的就是要将IAT项被重定向的流程修改为正确IAT项的处理流程（分析代码，找到正确的跳转处。）
	还有一点很重要：如果你按照上面的方法对不同的IAT设置内存写入断点，最后会发现不同的IAT会断在不同的地方，比如这里的460ADC就会断在MOV [EAX],ECX;而这条将IAT重定向
															460BAC就会断在MOV [EDI],EAX;这条将正确写入IAT项。所以这解释了上面提到的壳只会对一部分IAT重定向。
	【这个跳转法中应该注意的】所以，根据上面这条可以看出，需要多次给不同的IAT项设置内存写入断点，来找到重定向的代码处，和非重定向的代码处。由此来判断修改哪里的跳转




	*对IAT区域设置内存写入断点后，会在第一个写入IAT项处断下来，这个时候关键跳转已经存在，修改关键跳转为JMP，清除之前设置的内存写入断点，然后像之前跟踪OEP一样，对401000设置内存访问断点，之后就有两种可能：1，壳有自校验运行起来会失败。2，另一种运行起来正常。这里运行起来正常
	*用跳转法修复IAT后可以看到，原本无法修复的空指针，即find reference表是空的IAT项，被填充了00000000，
	
第三十八章：
（这章中的程序不能再win7下运行，需要在虚拟机中运行，OD任意，忽略异常都取消勾选）
168.这里在用ESP定律的时候和之前说的ESP定律有点不同：在设置硬件断点后，运行起来，来到跳转处，这个程序如果不给401000设置内存断点，单步步入步过后虽然能来到OEP处，但是F9运行起来后直接终止了（不知道为什么），而是需要在到达条转出设置401000内存访问断点才能正常运行（教程是这样描述的：查看异常处理程序入口地址，46590B，跳转处指令是465982，不出意外的话到达该异常处理程序，随后就会到达OEP给第一个区段设置内存访问断点，触发异常后，随即就会到达OEP）
169.有时候壳会检测自身的代码有没有被NOP掉。
170.这个例子中定位到关键跳后，尝试NOP掉关键指令，虽然IAT被修复了，但是壳有自校验所以无法运行。【方法】【关于壳有自校验】解决方法：1.再开一个OD，加载该程序的另一个实例，直接跟到OEP处，不修改任何东西，然后将当前这个实例的正确的IAT复制出来，覆盖掉新开的这个实例的IAT，注意是二进制复制，这个方法比较简单。（具体执行方法：选择全部正确的IAT――右键――二进制复制――在另一个OD中二进制粘贴――复制到可执行文件）		  2.直接用IMP REC 定位到该进程，此时IAT全部被写入正确的值了，但是还未到达OEP处，我们直接天上OEP，RVA,SIZE等数据，没有到达OEP处没有关系，直接单击Get Imports
171.在确定IMP REC三要素的时候可以在数据窗口中右键――长型――地址更直观看IAT
172.用SFX定位OEP的时候，定位的OEP不一定是正确的，需要判断。就像这章中的习题例子。见38章习题破解日志

第三十九章：stolen bytes（壳偷代码）
	//这章的例子需要在虚拟机中用patch OD才能运行出最后结果
	//用原版才能出现开始的异常窗口

而且用最后一次异常法找不到最有一次异常，勾选上所有忽略异常选项后，运行起来后并没有出现异常
2018/4.8/更新：无法找到最后一次异常解决方法：插件里strongOD――选项――取消勾选skip some exceptions	
	给KiUserExceptionDispatcher下断点后，取消勾选忽略所有异常，运行起来后会有异常，但是我没有异常显示，只在堆栈esp+14中看到了和教程中差不多的数值，也就是说如果没有教程，根本无法定位异常地址。
	为了使用最后一次异常法，按照教程的方法硬是来到最后一次异常处（因为中间产生好几处异常，都会断在KiUserExceptionDispatcher,但不需要为了一次次定位异常而去取消勾选忽略非法内存访问异常选项，取而代之的是更快的方法：条件断点，condition设置为[esp+14]==396744,按条件暂停程序，这里的396744是硬找出来的，OD日志中并没有给出确定的信息，我这里也不知道怎么设置...）接着就跟最后一次异常法一样，给401000设置内存访问断点，运行起来后来到伪OEP（为什么是伪OEP，参考175）




173.Ring3异常分发函数KiUserExceptionDispatcher,所有的异常都会经过这一个点。
174.OD不能跟进Ring0
	《加密与解密》中提到：保护模式下，所有应用程序都有权限级别（简称PL（全称：Privilege Level）），0,1,2,3等，（0最高）
15.当PL=0，或运行在Ring 0的的应用程序，他就可以执行所有的指令并访问所有的数据（如操作系统核心层）
动态链接库KERNEL32.DLL是运行再Ring 3级的，以提供与应用程序的接口

175.stolen bytes：即某些壳在处理OEP代码的时候会把OEP处固定的代码从壳空间开始执行，然后再JMP回原程序控件。如果我们脱掉壳，这一部分代码就会遗失，也就达到了反脱壳的目的

	解决方法：一种方式就是尝试跟踪壳的代码，当所有异常都触发以后，我们就会到达错误OEP处，我们将跟踪过程中执行过的代码都保存到txt中，便于分析。下面来看JMP到伪OEP之前都执行了什么：如果到达真正的OEP处是，栈顶应该是	在载入程序时的栈顶值（是12FFC4），但是该壳把OEP处前几行的代码清空掉了，并填入了垃圾数据（在伪OEP处前就可以看到填充垃圾数据的代码），所以对401000设置内妇女访问断点会断在伪OEP处，不会断在前面，并且把这前几行代码放到壳代码空间中去，接着在壳空间执行原程序的前几条指令，然后在JMP到原程序的伪OEP处。
	定位stolen bytes最常用的方法还是在最后一次异常产生后单步跟踪：
	还是先来到最后一次异常处，对CALL ZwContinue设置断点（这里为什么要对这个CALL设置断点？？答：ZwContinue的作用是继续执行一个线程，它的一个参数是CONTEXT指针，后面需要用到这个指针）运行起来，在数据窗口中定位栈顶值。
	这里栈顶值的是CONTEXT结构体的指针，如果熟悉CONTEXT结构的话，就会知道其中有个字段表示是EIP寄存器，其他一些字段表示的是其他一些寄存器，当异常处理完毕以后会根据CONTEXET结构中的EIP值来决定返回到哪里，CONTEXT结构具体见后面章节，现在只需要知道程序返回到哪里，现在EIP字段位于偏移B8处（可以参考VC中CONTXT结构体的定位），所以返回地址=[12FCE4+B8]=[12FD9C]=396746
	给该地址也就是396746所在区段设置一个内存访问断点，运行起来，断在396746处，然后调试――set condition，可供选择设置，比如：EIP is Range这一项设置内401000~475000，即原程序的所有区段，这样就能在run trace窗口（也就是【...】窗口）中看到跟踪过程中执行了哪些指令 Condition is TRUE这项设置ESP=12ffc4，即跟踪到栈顶指针跟伪OEP一致时，停止跟踪。注意这里调试选项中的Trace选项卡中的always trace over system DLLs 和Always trace over string commands也可以尝试勾选上，看看自动跟踪的效果如何，如果效果不好，再去掉勾选。跟踪完毕后，可以右键――将日志信息保存到文件再进一步分析。但这里看不出来哪里是真正的OEP。
	换一个条件：设置command is one of这一项，这里填入两条命令“popad”和“push EBP”即当遇到恢复寄存器环境或者OEP处常见的第一条指令时停止自动跟踪，EIP is in range不变（这里记得要把之前的内存断点移除）――trace into，F7每次会看到【缺失指令】然后到达伪OEP――将stolen bytes拷贝：按“-”回到刚才真正OEP的第一条指令处――一次见哥确实的指令所对应的字节码拷贝到记事本中（除了最后一个push和ret）：右键――binary――binary copy――粘贴。（共38个stolen bytes 即26H个），在4271D6-26H=4271b0处长度为26H的区域上右键――binary paste
	（这里至于trace into后哪些是真正的stolen bytes我也没搞清楚，这里跳过了）
――――――――
	*这里总结下关键步骤，给 KiUserExceptionDispatcher下了断点后，运行起来，给入口处设置条件断点，condition:[esp+14]==396744 expression:[esp+14],on condition,always,F9,给第二个call设置CC断点，F9，给390000区块设置内存访问断点，F9，set condition：EIP in range, Command is one of:popad和pushebp，移除之前的内存访问断点，trace into。之后用（大概是用）F7跟入，找可能正常的代码，这里我也不知道怎么去判断，就用了对比普遍性来判断，之后的代码有很多花指令，像无条件跳转JMP，int 20，sal esp，0等等，除了这些指令以外，应该就是stolen bytes
（就是说用F7单步，除了以上这些花指令之外的应该都是stolen bytes）2018/4/8更新：其实教程中说了如何判断哪些是stolenbytes，就是单步F7跟，理解“壳偷代码”的含义，偷的代码还是会执行，但是中间不能夹杂其他有效的代码，否则原程序就不能正常运行了，所以其实中间哪些无效的指令都是在欺骗分析者，像sal esp，0这种指令，指令确实执行了，但没有意义，esp左移0位，跟没有执行语句一样，所以F7单步分析就很容易得到stolenbytes

更新：在用最后一次异常法到达伪OEP后，如果发现了壳偷代码，这时候应该做的就是去分析最后一次异常和伪OEP之间的代码，来到最后一次异常后，找到CONTEXT结构，找到CONTEXT结构中的EIP，给该EIP所指向的区段设置内存访问断点，然后设置自动跟踪条件，（注意这里要有技巧得设置条件，这里用了Command is one of：popad，push ebp即当遇到恢复寄存器环境或者OEP出常见的第一条指令时停止跟踪，或者设置其他条件），然后Debug-Trace into。然后分析哪些是花指令、垃圾指令，然后将stolen bytes拷贝出来，填充到伪OEP处即可。
更新：这里有个问题：最近看到了SEH，其中就有CONTEXT结构，在找到stolen bytes中有个很关键的一步就是找到context结构，而教程中没有说明为什么定位到了一条call ZwContinue语句。
更新：这里解释上面这个问题，我在看雪上看到了答案：ZwContinue的作用是继续执行一个线程，而context结构就是用来描述一个线程的，所以现在可以理解了，ZwContinue的一个参数是context结构，找到EIP下断就可以了
2018/4/8更新：之前我还在想这个traceinto和条件断点有什么区别，这里可能是在修复stolenbytes时，就需要用到设置traceinto条件，我在ximo和这系列教程中都看到了这样的做法



第四十章：编写脚本让壳无法检测设置的硬件的断点
176.【OD】【file――attach】可以修复OD的一些bug
177.关于编写的这个让壳无法检测设置的硬件断点的思路：每次异常触发后都会断在KiUserExceptionDispatcher，接下来就会由操作系统去调用异常处理函数，这个时候我们设置硬件断点可以被检测到，所以这个脚本要做的就是当前断在KiUserExceptionDispatcher时，清除掉硬件断点，当断在下面的CALL ZwContinue时再将硬件断点恢复。
//以下的笔记是在2个月后开始重新记
178.在寻找IAT起始位置的时候，如果认为某个可疑项不是IAT，那么得查看参考引用，之后发现没有参考引用处，并且也不属于系统DLL的区段，才有可能确定这项不是IAT表中的项
179.关于教程中提到的：对照call [460930]的机器码推算出call[460F24]的机器码，我记得在看雪知识库里有提到，机器码是如何生成的
180.关于dump 和 anti-dump 可详见https://bbs.pediy.com/thread-17624.htm


第四十一章：	
181.发现我的win7 x64和xp系统有很大的不同，就对于这个程序来说，来到最后一次以后，x64系统无法进入Zwcontinue，而XP可以，甚至在x64的系统中，连最后一次异常地址所在的区段都在M中找不到。。
182.antidump包括：自校验，校验区段数目，检验映像大小
183.如果修复完IAT，仍然不能运行，除了《ximo》笔记中第9点，还可以考虑用OD重新载入当前的程序，分析程序为什么不能运行。这里是因为跳转到了一个不存在的区段，那么我们就手动添加这样一个区段：回到最开始：载入最原始的程序，来到伪OEP，LordPE载入当前进程，用LordPE区域转存，转存的区域为刚刚不存在的区段，然后用LordPE载入修复完IAT的程序，编辑PE，载入刚刚dump出来的区域，编辑这个区域，虚拟地址=区域地址-ImageBase。对修复完IAT的程序重建PE即可。

第四十二章：（FOEP：忽略所有异常，加上strOD）
184.直接用ximo的内存镜像法一次就来到了FOEP，来到最后一次异常后，直接traceinto条件 esp==12ffc4直接找到stolenbytes
185.关于判断是否有stolenbytes：先用最有一次异常法，来到FOEP，对比堆栈中的值的数量，如果比程序刚载入时多了2个，那么一般这种情况就存在stolenbytes。
186.调试寄存Dr7：见教程
187.定位stolenbytes时，如果定位到的stolenbytes处的EBP值刚好与FOEP处的EBP相等，说明定位到的stolenbytes是正确 的。
188.硬件断点是断在下一条指令处的。
189.IAT修复magic跳，应该在壳段修复，也就是在运行到stolenbytes之前修复。
	其实感觉也不用这样哦：用Kido方法：来到FOEP后，进入IAT，转到IAT某个函数的处理处，新建EIP，编写脚本，并且运行脚本。
	方法和《官方教程》第十课一样。
190.这章的程序用《官方教程》第十课的脚本一样可以修复。
191.修复IAT的时候，万一发现了有不能修复的项，可以跟一下看看哪里出了问题：在数据窗口中转到无效IAT项地址，对其设置内存访问断点,F7跟进分析到底调用的是哪个API，或者用traceinto：EIP is outside the range 0~500000.
192.【K】：查看调用堆栈
	在发生异常时，可以通过这个找到异常原因：右键――show call（或者直接双击），
	
	我在用补区段的方法的时候，遇到一个问题：补的区段为150000，那修改区段VA=？？可能这就是不能通过补区段来修复
	现在用教程中的方法来试试看：成功。
	这个程序我第一遍做的时候，不知道怎么的，在修补哪些JMP的时候，总是遗漏，不知道是在之前修复stolenbytes还是OEP的时候出错了，所以我重头再来了一遍，发现JMP 【XX】中的地址在正确的程序中也是可以找到的，（并不是像之前那样不能对应。）。
	*补区段的时候，在载入区段后记得修改区段的VA
	*这个程序的VA我不知道怎么处理，照理来说VA=DUMP出来的区段地址-IMAGEBASE，但因为就像之前说的，这步的运算结果是负数。我填入负数也不对，重建PE后会说这个程序不是有效的PE程序。

第四十五章：
193.【OD】：主菜单项中的Option-Just-in-time debugging可以将OD设置为即使调试：有程序崩溃的时候，OD就会自动附加上该程序。
194.【配置LordPE】：Break’n’Enter(LordPE)，Lord into PE editor
	脱壳笔记见《第45课破解过程》
	有挂起程序某个线程的软件。
195.PE中的Import Table和IAT是不同的：Import Table中有DLL名称字符串等等，而IAT就是单纯由地址组成的一章输入表。
196.在分析某个call的时候，就像这章中的分析call100058d0的时候，不应该从头分析到尾，只要看关键代码语句，比如这里的 REPE CMP BYTE PTR ES:[EDI],BYTE PTR DS:[ESI]，看到这样的关键语句就应该知道这个call在干什么。
197. 可以利用内存访问断点间接地完成API的监视工作不需要一步步单步跟踪：首先定位某个模块的IAT，方法和脱壳的一样，选中IAT中所有的地址，设置内存访问断点。


第四十八章：
	在xp下可以用最后一次异常法可以来到FOEP，win7不行

198.【OD Patch4】专用定位OEP的OD是仅当内存执行断点，只有执行才会断下，读取和写入并不会断下。
199.这里找stolebytes的时候又遇到另一种情况：stolenbytes可能在某次EIP之前的一条语句。
200.*有时候12ffc4找stolenbytes可能不能用，就对12ffc0设置硬件访问断点，有可能就断在stolenbytes的附近，注意是附近。
201.有的API入口点OD并不会提示调用了什么API，这是拖动反汇编窗口内存地址的黑线就可以看到API的名称了。
202.




























































