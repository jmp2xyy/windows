――――――――
配合《从0crack》中的第三十二章脱壳笔记及其他章节一起看


1.单步跟踪脱壳的原则向上的跳转不能让实现，可以向下跳转

	*近callF7跟进，远CALLF8步过

2.FSG壳：有个特殊ESP定律：单步运行来到POPAD语句后面，发现堆栈窗口中被压入了多个值，在这些值中的第4个值，右键，在反汇编窗口中跟随，设置硬件执行断点，运行起来后（F9或shiftF9）就能来到OEP‘

PS：回到最后一次异常法，我用FSG加壳工具给我带有SEH的程序加壳，想看看用最后一次异常法能不能脱了FSG，但是发现，程序并不能断在我自己设计的异常地址，也就是说无法定位最后一次异常，也就没法给代码段设置内存访问断点后来到OEP，所以我感觉这个最后一次异常法的异常，应该是在壳段的异常，被设计在壳段中，（不知道《免杀攻防》里有没有提到这点：如何用异常免杀）

3.如果进入某个call 或者ret 语句或者别的语句，程序就跑飞了或者跑起来了，那就在这些语句的下面一条语句下断点，这样才有可能到达OEP

4.合并到第9点

5.第7课中，手脱TElock：ximo教程中是在最后一次异常后来到SE句柄，然后单步跟到OEP，我这里用《从0crack》中的方法，在最后一次异常后，直接对代码段设置内存访问断点，esto后直接来到了OEP

	*发现ximo的内存镜像法设置内存断点顺序都是不变的，都是先资源段然后再代码段，
	*但是先代码段，后rdata段，再代码段，也可以脱
	更新：《从0crack》提到：“有的OEP不在第一区段，要对剩下别的区段依次设内存访问断点，然后运行”。这里教程中用的patchOD，即直接对某个区段设置内存访问断点，运行就可以，（同2次内存镜像法），那么也就是说顺序可能确实不是固定的。

	*还有就是对某个区段设置断点不一定要用F2，也可以用内存访问断点（这2者好像没区别...，我看ximo都是F2，我比较喜欢设内存访问断点）更新：有的壳会检测CC断点，所以最好用内存访问断点
	*用模拟运行法的前提是程序没有SEH安装，但是这里又有个技巧：利用最后一次异常，因为程序在最后一次异常后，就没有SEH安装了。就可以用模拟运行法了
	*在利用最后一次异常法的SFX时，注意有个关键点，就是来到最后一次异常后，需要在堆栈窗口中寻找SE句柄，在反汇编窗口中跟随，下断，esto，然后再在命令行中输入 tc eip<(sfx区段)
	**当ImportREC修复IAT的时候如果等级1和等级3都没法修复IAT，那么可以这么做：打开原来那个需要脱壳的程序，然后用IMPORREC去载入，输入OEP等参数，然后再用等级3修复，（剪切无效IAT等步骤就不说了），然后再fix 已dumped的程序

6.第8课：
	对IsDebuggerPresent下断后，记得要删除对这个API的断点，否则，就像这个程序一样，会检测这个API的开头是否为CC，也就是有没有被设断点，（OD对某条语句设断，就是改着条语句为CC，但因为方便理解OD没显示CC），然后直接终止了程序。
	这课的壳对程序最后做了手脚：如果查找到对IsDebuggerPresent的断点，就用乱码填充原代码
7.第9课：
	有的程序即使来到跳往OEP的大跳，如果强行实现大跳，IAT会修复失败
	找关键跳，找关键跳的判断语句，设置条件断点
8.处理overlay数据，用十六进制工具将附加数据附加到脱完壳的程序后面即可

9.第12课：
	IAT修复完后仍然不能运行，考虑自校验问题
	4.修复完IAT都没法运行，可以用LordPE重建PE的方法试试
	第13课：很多被加壳的 PE 文件在脱壳以后，往往该 PE 文件的资源部分无法用某些资源工具进行查看、编辑，同时也不利于脱壳文件的优化工作	,这是可以用资源修复器Fixres

10.第13课：合并到第9点



	用设置内存访问断点的最后一次异常
	用ximo的2次内存镜像法脱89课作业：失败

11.第14课：
	关于脱加变形壳工具：程序一开始先由未知壳组成，然后再是asp壳特征pushad，pushfs。所以需要从一开始的地方找到关键入栈，再用esp脱才能来到OEP（这中类型的壳之前没有见过，所以笔记也说不清楚2018/4/8更）


12.第16课：
	异常处理无法停下见第17章。
	ximo的异常处理法很怪，之前的程序也是，我觉得都可以来到最后一次异常后，直接对代码段设置内存访问断点，esto就直接来到OEP了，但是ximo喜欢单步，他通过再下断点运行到return语句在内代码段设置内存访问断。（但是我这个方法也有问题：见第17课）


12.第17课：
	【OD】【strong OD】:这章的ACprotec，如果用52OD不会中断在异常（异常无法暂停），解答：OD插件――strongOD――option――skip some exceptions选项取消重启OD即可（在win7下还是不能解决这个问题，但在XP下可以解决）
	**针对第16课中我和ximo不一样的最后一次异常法有个问题：就是ximo在这节说到达retn后才是跟踪stolen byte的最好时机，那么如果按照我的方法：直接来到最后一次异常――>代码段设置内存访问断点后直接来到了OEP，那么该如何确定哪里是跟踪stolenbytes？所以也有短板。（这里看下《从0crack》是怎么解决的？？）
	《从0crack》这样提到：虽然有很多方法定位stolenbytes，但是最为常见的还是在最后一次异常后单步跟踪。
	两个教程来到最后一次异常的方法不同，ximo是来到最后一次异常，找堆栈窗口的SE句柄，然后通过下内存访问断点来到retn语句（这里不知道为什么一定要来到retn语句），而《从0》是通过来到最后一次异常后，shiftF7跟进系统异常处理领空，断到Zwcontinue，看context指针的EIP返回到哪里，然后在该指针指向的区段设置内存访问断点，运行起来后断下来，然后traceinto找stolenbytes（*我试了《从0》的这个方法，要找到stolenbytes需要traceinto 2次，我是用ESP=12ffc4这个条件跟的，要跟踪2次可能是因为我条件设置的不够全面）
	*这里OD又出现了问题：ximo在设置步入条件后，运行起来后就能找到stolenbytes，而我却进入了系统领空，不知道为什么。已在52发帖子询问，2018/4/8
	上面这个应该可以通过设置来解决，调试选项――跟踪――跟踪总是步过系统DLL，总是跟踪步过串操作指令，但是我就是无法跟踪到stolenbytes，停不下来。。。
	更新：用另一个方法可以找到stolenbytes！用《从0crack》提到的用条件为真：esp=12ffc4，（这个值是刚载入程序时堆栈栈顶esp的指针,当到达真正的OEP处时,一般来说,栈顶指针应该也会指向12FFC4或者附近的地址），这个程序用IMPREC的等级3修复IAT会卡死，需要重新开一个进程来修复，OEP还是填新的EIP（因为找到stolenbytes后要填充到伪OEP之前，并且设置第一句为新EIP）
	注意这里esp=栈顶指针，不是栈顶的值
	

	*这里教程有个BUG，就是ximo来到伪OEP后，直接将traceinto的条件设置为VC++的入口点push ebp mov ebp,esp了，因为他知道这个是VC++，那如果不知道源程序是用什么代码写的，那该下什么traceinto条件？？
	*这个程序应该也可以用《从0crack》第39章中的方法找到伪OEP，就是利用ZwContinu，的context->eip指针


	


13.ImportREC对某些新系统的DLL的API修复不是很好，最好用Scylla工具脱壳

14.第18课：
	不仅ACprotect程序运行到的真OEP时栈顶指针为刚加载程序时的指针，而且其他加壳程序也是这个特点；那是不是所有壳，或者大部分壳都可以用这个方法？（traceinto ，esp=栈顶指针）（我试了下UPX用这个方法，速度非常慢，不如ESP定律快，而且还不太准确）

	
	我用ximo的方法给12ffc4这个值下硬件访问断点，不能断下来，只能用跟踪法，但是跟踪法断下来以后怎么去判断哪些是OEP，这次这个程序不像《从0》中介绍的可以用单步来判断，这个程序来到真OEP后，下面还有很多CALL语句，那这些CALL语句要跟进去吗？
	*发现不同壳的stolenbytes有不同的特征：例如这章的程序和上一章的程序都是ACprotect，他们的stolenbytes特征是：当traceinto断下来后，有两条pushad语句，这两条语句上面的就是stolenbytes，而《从0》39章的程序是而PElock壳，stolenbytes的特征是：当traceinto断下来后，单步执行的有效语句就是stolenbytes。（这条笔记我只是比较了3个程序，不知道有没有普遍性，仅供参考）
	*ACprotect壳的高版本即使找到了stolenbytes，修复了IAT，也有可能不能运行起来，因为这壳有个保护功能，当读取入口代码和他自己设的代码不同的时候，一些代码就无法解密，还需要做处理
	处理过程：查看原来程序的入口点，在修复完IAT的程序中转到这个入口点，将stolenbytes还是写到入口点，再添加跳到真OEP的地址的语句，jmp xxx或者push xx ，ret然后保存修改，但是此时程序还是不能运行，因为程序的入口点还是没变，需要用LordPE修改入口点，修改为原程序原来的入口点。
	*我测试了17和18课的壳，发现《从0》的方法：来到最后一次异常后F7跟到Zwcontinue的方法都能脱这几个壳，但是ximo的方法就不能拖《从0》第39课的壳，因为39课的程序没有17,18课壳的return语句，我都不知道ximo为什么要F4到retn语句，也不知道为什么retn是最佳的traceinto时机。所以现在来看，用Zwcontinue的方法好一些
	*！更新：*发现ximo的方法也可以脱39课的壳：来到SE句柄后，需要按一次F7才可以跟踪，否则程序就直接运行了，可这是为什么？更新：后来操作却又失败了，需要来到SE句柄后shift+F7自动跟踪一会，然后traceinto，才能看到stolenbytes，但是就是不知道需要自动跟踪到哪里

15.第19课：
	注意VB程序，在补stolenbytes的时候，第一个push是来到伪OEP堆栈窗口中第二个数值，至于为什么不用traceinto找stolenbytes，我试了下，发现有几个问题：1，命令设置条件命令push 00404754也没用，还是断不下来，设置esp==12ffc4也没断不下来。2，不论用ximo的方法还是Zwcontinue来到最后一次异常，都无法traceinto到stolenbytes。


16.第20课：
	这章提到一点：不用完全脱壳也可以做到或者达到破解的目的：用esp定律对第一个pushad设置内存访问断点，然后运行到最后一次异常的地方（标志就是在某次运行后来到的系统Zwcontinue，那么前一次就是要找的），这里就是脱壳的最佳时机，然后用LordPE脱壳，IR修复（OEP填假的OEP），这里填假的OEP是为了修复IAT，但是如果这个时候就fix，那么程序还是无法运行的，这里需要在修复IAT后，修改OEP的地址，就是改为最后一次异常的地址，至此就可以破解（但是壳还是保留着）
	

17.第21课：
	*补区段
	1.先脱壳脱到FOEP，然后修复IAT
	2.，重载，esp定律，多次F9来到MOV指令，mov指令后面pushad前面的就是stolenbytes，复制stolenbyts，用工具为步骤1脱完的程序添加一个区段，复制stolenbyts进这个程序，在代码的最后面添加jmp xxx（FOEP），保存修改，用LordPE修改入口点为stolenbyts的开头


18.第22课：
	*关于用最后一次异常法来到OEP的又一个方法：在到达ret后，给堆栈窗口中第4个数值下硬件访问断点，来到JMP，F7后就来到了OEP

19.第23课：
	*关于traceinto，当设置esp==12ffc4断下来后，有可能断的不是stolenbytes，再多次ctrl F11分析后面断下来的代码，（多数后面来到的push ebp开始就是stolenbyts）

20.第24课：
	*以壳解壳：实用性受限，只有stolenbytes太多的时候再用，而且如果有校验，那么更不能用这个方法。
	先找到最佳以壳脱壳的地方，dump，然后用LordPE区域转存，用LordPE的PE编辑器载入dump完的程序――区段――右键从磁盘载入刚刚dump区域，右键编辑这个区段，区域的VR=区域开始地址-ImageBase――保存。然后重建添加完区段的dump的PE：（注意LordPE的选项右下角那部分仅选则使PE有效），然后修复IAT，OEP填假OEP，等IAT全修复了后，再修改OEP为最佳壳解壳的地址
	


21.《从0》：有时候12ffc4找stolenbytes可能不能用，就对12ffc0设置硬件访问断点，有可能就断在stolenbytes的附近，注意是附近。



熟悉各种语言的入口点

×	现在：用ximo的方法，但是只执行一次F7，看看能不能找到stolenbyts――>失败
	
×	二次内存镜像法的原理是什么？
×	BP VirtualFree 的原理
×	LordPE重建PE的原理
×	tc eip< sfx区段的原理

×	从0开始crack：在用impREC等级1和等级3时都无法修复的时候该怎么办
√	ximo第十七课，找stolenbytes的时候用跟踪步入，但是我的跟踪步入后直接进入了系统领空，找不到stolenbytes――>strongOD skip someexceptions

√	程序刚被OD载入时，堆栈中被压的值和指针都是什么？也就是12ffc4的原理――>在OD中设置：事件――将中断与xxx都勾选上，就能看到程序初始化堆栈的效果。
		但是我发现：XP和win7还有点不同，按上面的做，在win7下确实能看到堆栈初始化的情况，堆栈中都是000，就好像新的一样，但是xp下，就会发现esp上下都有很多值，就像是未被清理的值一样
×	19课的bp getprocessid，查OD pid，更改mov中的源操作数，运行bp getmodulehandle，给代码段设置内存访问断点的原理？
×	为什么有的程序异常断不下来，但是有的时候能断下来？例如20课的这个程序
×	如何手工为PE添加一个区段
×	第22课的第4个堆栈数值的原理？Zwcontinue？



























